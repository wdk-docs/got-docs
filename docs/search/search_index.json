{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\/\\s\\-\\.]+"},"docs":[{"location":"","text":"Got \u6587\u6863 \u00b6 Sindre's open source work is supported by the community. Special thanks to: Strapi is the leading open-source headless CMS. It\u2019s 100% JavaScript, fully customizable, and developer-first. Paperwork that makes the data work. Easy APIs for paperwork. PDF generation, e-signature and embeddable no-code webforms. The easiest way to build paperwork automation into your product. Paperwork that makes the data work. Easy APIs for paperwork. PDF generation, e-signature and embeddable no-code webforms. The easiest way to build paperwork automation into your product. Human-friendly and powerful HTTP request library for Node.js See how Got compares to other HTTP libraries For browser usage, we recommend Ky by the same people. Support questions should be asked here . Install \u00b6 1 npm install got Warning: This package is native ESM and no longer provides a CommonJS export. If your project uses CommonJS, you'll have to convert to ESM or use the dynamic import() function. Please don't open issues for questions regarding CommonJS / ESM. We will only backport critical security issues to Got v11, not features or bug fixes. Take a peek \u00b6 A quick start guide is available. JSON mode \u00b6 Got has a dedicated option for handling JSON payload.\\ Furthermore, the promise exposes a .json<T>() function that returns Promise<T> . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { json : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> {\"hello\": \"world\"} For advanced JSON usage, check out the parseJson and stringifyJson options. For more useful tips like this, visit the Tips page. Highlights \u00b6 Used by 8K+ packages and 4M+ repos Actively maintained Trusted by many companies Documentation \u00b6 By default, Got will retry on failure. To disable this option, set options.retry.limit to 0. Main API \u00b6 Promise API Options Stream API Pagination API Advanced HTTPS API HTTP/2 support Response class Timeouts and retries \u00b6 Advanced timeout handling Retries on failure Errors with metadata Advanced creation \u00b6 Hooks Instances Progress events & other events Plugins Compose Cache, Proxy and UNIX sockets \u00b6 RFC compliant caching Proxy support Unix Domain Sockets Integration \u00b6 TypeScript support AWS Testing Migration guides \u00b6 Request migration guide (Note that Request is unmaintained) Axios Node.js Got plugins \u00b6 got4aws - Got convenience wrapper to interact with AWS v4 signed APIs gh-got - Got convenience wrapper to interact with the GitHub API gl-got - Got convenience wrapper to interact with the GitLab API gotql - Got convenience wrapper to interact with GraphQL using JSON-parsed queries instead of strings got-fetch - Got with a fetch interface got-scraping - Got wrapper specifically designed for web scraping purposes got-ssrf - Got wrapper to protect server-side requests against SSRF attacks Legacy \u00b6 travis-got - Got convenience wrapper to interact with the Travis API graphql-got - Got convenience wrapper to interact with GraphQL Comparison \u00b6 got node-fetch ky axios superagent HTTP/2 support \u00b9 ** Browser support * Promise API Stream API Node.js only Pagination API Request cancelation RFC compliant caching Cookies (out-of-box) Follows redirects Retries on failure Progress events *** Browser only Handles gzip/deflate Advanced timeouts Timings Errors with metadata JSON mode Custom defaults Composable Hooks Issues open Issues closed Downloads Coverage TBD Build Bugs Dependents Install size GitHub stars TypeScript support Last commit * It's almost API compatible with the browser fetch API.\\ ** Need to switch the protocol manually. Doesn't accept PUSH streams and doesn't reuse HTTP/2 sessions.\\ *** Currently, only DownloadProgress event is supported, UploadProgress event is not supported.\\ \u00b9 Requires Node.js 15.10.0 or above.\\ Almost-stable feature, but the API may change. Don't hesitate to try it out!\\ Feature in early stage of development. Very experimental. Click here to see the install size of the Got dependencies. Maintainers \u00b6 Sindre Sorhus Szymon Marczak Former \u00b6 Vsevolod Strukchinsky Alexander Tesfamichael Brandon Smith Luke Childs Giovanni Minotti These amazing companies are using Got \u00b6 Segment is a happy user of Got! Got powers the main backend API that our app talks to. It's used by our in-house RPC client that we use to communicate with all microservices. \u2014 Vadim Demedes Antora, a static site generator for creating documentation sites, uses Got to download the UI bundle. In Antora, the UI bundle (aka theme) is maintained as a separate project. That project exports the UI as a zip file we call the UI bundle. The main site generator downloads that UI from a URL using Got and streams it to vinyl-zip to extract the files. Those files go on to be used to create the HTML pages and supporting assets. \u2014 Dan Allen GetVoIP is happily using Got in production. One of the unique capabilities of Got is the ability to handle Unix sockets which enables us to build a full control interfaces for our docker stack. \u2014 Daniel Kalen We're using Got inside of Exoframe to handle all the communication between CLI and server. Exoframe is a self-hosted tool that allows simple one-command deployments using Docker. \u2014 Tim Ermilov Karaoke Mugen uses Got to fetch content updates from its online server. \u2014 Axel Terizaki Renovate uses Got, gh-got and gl-got to send millions of queries per day to GitHub, GitLab, npmjs, PyPi, Packagist, Docker Hub, Terraform, CircleCI, and more. \u2014 Rhys Arkins Resistbot uses Got to communicate from the API frontend where all correspondence ingresses to the officials lookup database in back. \u2014 Chris Erickson Natural Cycles is using Got to communicate with all kinds of 3 rd -party REST APIs (over 9000!). \u2014 Kirill Groshkov Microlink is a cloud browser as an API service that uses Got widely as the main HTTP client, serving ~22M requests a month, every time a network call needs to be performed. \u2014 Kiko Beats We\u2019re using Got at Radity. Thanks for such an amazing work! \u2014 Mirzayev Farid Got has been a crucial component of Apify's scraping for years. We use it to extract data from billions of web pages every month, and we really appreciate the powerful API and extensibility, which allowed us to build our own specialized HTTP client on top of Got. The support has always been stellar too. \u2014 Ondra Urban For enterprise \u00b6 Available as part of the Tidelift Subscription. The maintainers of got and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.","title":"Got \u6587\u6863"},{"location":"#got","text":"Sindre's open source work is supported by the community. Special thanks to: Strapi is the leading open-source headless CMS. It\u2019s 100% JavaScript, fully customizable, and developer-first. Paperwork that makes the data work. Easy APIs for paperwork. PDF generation, e-signature and embeddable no-code webforms. The easiest way to build paperwork automation into your product. Paperwork that makes the data work. Easy APIs for paperwork. PDF generation, e-signature and embeddable no-code webforms. The easiest way to build paperwork automation into your product. Human-friendly and powerful HTTP request library for Node.js See how Got compares to other HTTP libraries For browser usage, we recommend Ky by the same people. Support questions should be asked here .","title":"Got \u6587\u6863"},{"location":"#install","text":"1 npm install got Warning: This package is native ESM and no longer provides a CommonJS export. If your project uses CommonJS, you'll have to convert to ESM or use the dynamic import() function. Please don't open issues for questions regarding CommonJS / ESM. We will only backport critical security issues to Got v11, not features or bug fixes.","title":"Install"},{"location":"#take-a-peek","text":"A quick start guide is available.","title":"Take a peek"},{"location":"#json-mode","text":"Got has a dedicated option for handling JSON payload.\\ Furthermore, the promise exposes a .json<T>() function that returns Promise<T> . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { json : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> {\"hello\": \"world\"} For advanced JSON usage, check out the parseJson and stringifyJson options. For more useful tips like this, visit the Tips page.","title":"JSON mode"},{"location":"#highlights","text":"Used by 8K+ packages and 4M+ repos Actively maintained Trusted by many companies","title":"Highlights"},{"location":"#documentation","text":"By default, Got will retry on failure. To disable this option, set options.retry.limit to 0.","title":"Documentation"},{"location":"#main-api","text":"Promise API Options Stream API Pagination API Advanced HTTPS API HTTP/2 support Response class","title":"Main API"},{"location":"#timeouts-and-retries","text":"Advanced timeout handling Retries on failure Errors with metadata","title":"Timeouts and retries"},{"location":"#advanced-creation","text":"Hooks Instances Progress events & other events Plugins Compose","title":"Advanced creation"},{"location":"#cache-proxy-and-unix-sockets","text":"RFC compliant caching Proxy support Unix Domain Sockets","title":"Cache, Proxy and UNIX sockets"},{"location":"#integration","text":"TypeScript support AWS Testing","title":"Integration"},{"location":"#migration-guides","text":"Request migration guide (Note that Request is unmaintained) Axios Node.js","title":"Migration guides"},{"location":"#got-plugins","text":"got4aws - Got convenience wrapper to interact with AWS v4 signed APIs gh-got - Got convenience wrapper to interact with the GitHub API gl-got - Got convenience wrapper to interact with the GitLab API gotql - Got convenience wrapper to interact with GraphQL using JSON-parsed queries instead of strings got-fetch - Got with a fetch interface got-scraping - Got wrapper specifically designed for web scraping purposes got-ssrf - Got wrapper to protect server-side requests against SSRF attacks","title":"Got plugins"},{"location":"#legacy","text":"travis-got - Got convenience wrapper to interact with the Travis API graphql-got - Got convenience wrapper to interact with GraphQL","title":"Legacy"},{"location":"#comparison","text":"got node-fetch ky axios superagent HTTP/2 support \u00b9 ** Browser support * Promise API Stream API Node.js only Pagination API Request cancelation RFC compliant caching Cookies (out-of-box) Follows redirects Retries on failure Progress events *** Browser only Handles gzip/deflate Advanced timeouts Timings Errors with metadata JSON mode Custom defaults Composable Hooks Issues open Issues closed Downloads Coverage TBD Build Bugs Dependents Install size GitHub stars TypeScript support Last commit * It's almost API compatible with the browser fetch API.\\ ** Need to switch the protocol manually. Doesn't accept PUSH streams and doesn't reuse HTTP/2 sessions.\\ *** Currently, only DownloadProgress event is supported, UploadProgress event is not supported.\\ \u00b9 Requires Node.js 15.10.0 or above.\\ Almost-stable feature, but the API may change. Don't hesitate to try it out!\\ Feature in early stage of development. Very experimental. Click here to see the install size of the Got dependencies.","title":"Comparison"},{"location":"#maintainers","text":"Sindre Sorhus Szymon Marczak","title":"Maintainers"},{"location":"#former","text":"Vsevolod Strukchinsky Alexander Tesfamichael Brandon Smith Luke Childs Giovanni Minotti","title":"Former"},{"location":"#these-amazing-companies-are-using-got","text":"Segment is a happy user of Got! Got powers the main backend API that our app talks to. It's used by our in-house RPC client that we use to communicate with all microservices. \u2014 Vadim Demedes Antora, a static site generator for creating documentation sites, uses Got to download the UI bundle. In Antora, the UI bundle (aka theme) is maintained as a separate project. That project exports the UI as a zip file we call the UI bundle. The main site generator downloads that UI from a URL using Got and streams it to vinyl-zip to extract the files. Those files go on to be used to create the HTML pages and supporting assets. \u2014 Dan Allen GetVoIP is happily using Got in production. One of the unique capabilities of Got is the ability to handle Unix sockets which enables us to build a full control interfaces for our docker stack. \u2014 Daniel Kalen We're using Got inside of Exoframe to handle all the communication between CLI and server. Exoframe is a self-hosted tool that allows simple one-command deployments using Docker. \u2014 Tim Ermilov Karaoke Mugen uses Got to fetch content updates from its online server. \u2014 Axel Terizaki Renovate uses Got, gh-got and gl-got to send millions of queries per day to GitHub, GitLab, npmjs, PyPi, Packagist, Docker Hub, Terraform, CircleCI, and more. \u2014 Rhys Arkins Resistbot uses Got to communicate from the API frontend where all correspondence ingresses to the officials lookup database in back. \u2014 Chris Erickson Natural Cycles is using Got to communicate with all kinds of 3 rd -party REST APIs (over 9000!). \u2014 Kirill Groshkov Microlink is a cloud browser as an API service that uses Got widely as the main HTTP client, serving ~22M requests a month, every time a network call needs to be performed. \u2014 Kiko Beats We\u2019re using Got at Radity. Thanks for such an amazing work! \u2014 Mirzayev Farid Got has been a crucial component of Apify's scraping for years. We use it to extract data from billions of web pages every month, and we really appreciate the powerful API and extensibility, which allowed us to build our own specialized HTTP client on top of Got. The support has always been stellar too. \u2014 Ondra Urban","title":"These amazing companies are using Got"},{"location":"#for-enterprise","text":"Available as part of the Tidelift Subscription. The maintainers of got and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. Learn more.","title":"For enterprise"},{"location":"1-promise/","text":"Promise API \u00b6 Source code: source/as-promise/index.ts The main Got function returns a Promise . Although in order to support cancelation, PCancelable is used instead of pure Promise . got(url: string | URL, options?: OptionsInit , defaults?: Options ) \u00b6 Returns: Promise< Response > The most common way is to pass the URL as the first argument, then the options as the second. 1 2 3 4 5 6 7 import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { headers : { foo : \"bar\" , }, }). json (); got(options: OptionsInit ) \u00b6 Returns: Promise< Response > Alternatively, you can pass only options containing a url property. 1 2 3 4 5 6 7 8 import got from \"got\" ; const { headers } = await got ({ url : \"https://httpbin.org/anything\" , headers : { foo : \"bar\" , }, }). json (); This is semantically the same as the first approach. promise.json<T>() \u00b6 Returns: Promise<T> A shortcut method that gives a Promise returning a JSON object. It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'json' . promise.buffer() \u00b6 Returns: Promise<Buffer> A shortcut method that gives a Promise returning a Buffer . It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'buffer' . promise.text() \u00b6 Returns: Promise<string> A shortcut method that gives a Promise returning a string. It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'text' . promise.cancel(reason?: string) \u00b6 Cancels the request and optionally provide a reason. The cancellation is synchronous. Calling it after the promise has settled or multiple times does nothing. This will cause the promise to reject with CancelError . promise.isCanceled \u00b6 \u7c7b\u578b: boolean Whether the promise is canceled. promise.on(event, handler) \u00b6 The events are the same as in Stream API . promise.off(event, handler) \u00b6 Removes listener registered with promise.on 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { createReadStream } from \"node:fs\" ; import got from \"got\" ; const ongoingRequestPromise = got . post ( uploadUrl , { body : createReadStream ( \"sample.txt\" ), }); const eventListener = ( progress : Progress ) => { console . log ( progress ); }; ongoingRequestPromise . on ( \"uploadProgress\" , eventListener ); setTimeout (() => { ongoingRequestPromise . off ( \"uploadProgress\" , eventListener ); }, 500 ); await ongoingRequestPromise ;","title":"Promise API"},{"location":"1-promise/#promise-api","text":"Source code: source/as-promise/index.ts The main Got function returns a Promise . Although in order to support cancelation, PCancelable is used instead of pure Promise .","title":"Promise API"},{"location":"1-promise/#goturl-string-url-options-optionsinit-defaults-options","text":"Returns: Promise< Response > The most common way is to pass the URL as the first argument, then the options as the second. 1 2 3 4 5 6 7 import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { headers : { foo : \"bar\" , }, }). json ();","title":"got(url: string | URL, options?: OptionsInit, defaults?: Options)"},{"location":"1-promise/#gotoptions-optionsinit","text":"Returns: Promise< Response > Alternatively, you can pass only options containing a url property. 1 2 3 4 5 6 7 8 import got from \"got\" ; const { headers } = await got ({ url : \"https://httpbin.org/anything\" , headers : { foo : \"bar\" , }, }). json (); This is semantically the same as the first approach.","title":"got(options: OptionsInit)"},{"location":"1-promise/#promisejsont","text":"Returns: Promise<T> A shortcut method that gives a Promise returning a JSON object. It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'json' .","title":"promise.json&lt;T&gt;()"},{"location":"1-promise/#promisebuffer","text":"Returns: Promise<Buffer> A shortcut method that gives a Promise returning a Buffer . It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'buffer' .","title":"promise.buffer()"},{"location":"1-promise/#promisetext","text":"Returns: Promise<string> A shortcut method that gives a Promise returning a string. It is semantically the same as settings options.resolveBodyOnly to true and options.responseType to 'text' .","title":"promise.text()"},{"location":"1-promise/#promisecancelreason-string","text":"Cancels the request and optionally provide a reason. The cancellation is synchronous. Calling it after the promise has settled or multiple times does nothing. This will cause the promise to reject with CancelError .","title":"promise.cancel(reason?: string)"},{"location":"1-promise/#promiseiscanceled","text":"\u7c7b\u578b: boolean Whether the promise is canceled.","title":"promise.isCanceled"},{"location":"1-promise/#promiseonevent-handler","text":"The events are the same as in Stream API .","title":"promise.on(event, handler)"},{"location":"1-promise/#promiseoffevent-handler","text":"Removes listener registered with promise.on 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { createReadStream } from \"node:fs\" ; import got from \"got\" ; const ongoingRequestPromise = got . post ( uploadUrl , { body : createReadStream ( \"sample.txt\" ), }); const eventListener = ( progress : Progress ) => { console . log ( progress ); }; ongoingRequestPromise . on ( \"uploadProgress\" , eventListener ); setTimeout (() => { ongoingRequestPromise . off ( \"uploadProgress\" , eventListener ); }, 500 ); await ongoingRequestPromise ;","title":"promise.off(event, handler)"},{"location":"10-instances/","text":"Instances \u00b6 Source code: source/create.ts got.defaults \u00b6 options \u00b6 \u7c7b\u578b: Options The options used for this instance. handlers \u00b6 \u7c7b\u578b: Handler[] 1 ( options : Options , next : \u2026 ) => next ( options ) An array of handlers. The next function returns a Promise or a Request Got stream . You execute them directly by calling got(\u2026) . They are some sort of \"global hooks\" - these functions are called first. The last handler (it's invisible) is either asPromise or asStream , depending on the options.isStream property. mutableDefaults \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Determines whether got.defaults.options can be modified. got.extend(\u2026options, \u2026instances) \u00b6 Tip: options can include handlers and mutableDefaults . Note: Properties that are not enumerable, such as body , json , and form , will not be merged. Configure a new got instance with merged default options. The options are merged with the parent instance's defaults.options using options.merge(\u2026) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import got from \"got\" ; const client = got . extend ({ prefixUrl : \"https://httpbin.org\" , headers : { \"x-foo\" : \"bar\" , }, }); const { headers } = await client . get ( \"headers\" ). json (); console . log ( headers [ \"x-foo\" ]); //=> 'bar' const jsonClient = client . extend ({ responseType : \"json\" , resolveBodyOnly : true , headers : { \"x-lorem\" : \"impsum\" , }, }); const { headers : headers2 } = await jsonClient . get ( \"headers\" ); console . log ( headers2 [ \"x-foo\" ]); //=> 'bar' console . log ( headers2 [ \"x-lorem\" ]); //=> 'impsum' Note: Handlers can be asynchronous and can return a Promise , but never a Promise<Stream> if options.isStream is true . Streams must always be handled synchronously. In order to perform async work using streams, the beforeRequest hook should be used instead. The recommended approach for creating handlers that can handle both promises and streams is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import got from \"got\" ; // Create a non-async handler, but we can return a Promise later. const handler = ( options , next ) => { if ( options . isStream ) { // It's a Stream, return synchronously. return next ( options ); } // For asynchronous work, return a Promise. return ( async () => { try { const response = await next ( options ); response . yourOwnProperty = true ; return response ; } catch ( error ) { // Every error will be replaced by this one. // Before you receive any error here, // it will be passed to the `beforeError` hooks first. // Note: this one won't be passed to `beforeError` hook. It's final. throw new Error ( \"Your very own error.\" ); } })(); }; const instance = got . extend ({ handlers : [ handler ] });","title":"Instances"},{"location":"10-instances/#instances","text":"Source code: source/create.ts","title":"Instances"},{"location":"10-instances/#gotdefaults","text":"","title":"got.defaults"},{"location":"10-instances/#options","text":"\u7c7b\u578b: Options The options used for this instance.","title":"options"},{"location":"10-instances/#handlers","text":"\u7c7b\u578b: Handler[] 1 ( options : Options , next : \u2026 ) => next ( options ) An array of handlers. The next function returns a Promise or a Request Got stream . You execute them directly by calling got(\u2026) . They are some sort of \"global hooks\" - these functions are called first. The last handler (it's invisible) is either asPromise or asStream , depending on the options.isStream property.","title":"handlers"},{"location":"10-instances/#mutabledefaults","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Determines whether got.defaults.options can be modified.","title":"mutableDefaults"},{"location":"10-instances/#gotextendoptions-instances","text":"Tip: options can include handlers and mutableDefaults . Note: Properties that are not enumerable, such as body , json , and form , will not be merged. Configure a new got instance with merged default options. The options are merged with the parent instance's defaults.options using options.merge(\u2026) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import got from \"got\" ; const client = got . extend ({ prefixUrl : \"https://httpbin.org\" , headers : { \"x-foo\" : \"bar\" , }, }); const { headers } = await client . get ( \"headers\" ). json (); console . log ( headers [ \"x-foo\" ]); //=> 'bar' const jsonClient = client . extend ({ responseType : \"json\" , resolveBodyOnly : true , headers : { \"x-lorem\" : \"impsum\" , }, }); const { headers : headers2 } = await jsonClient . get ( \"headers\" ); console . log ( headers2 [ \"x-foo\" ]); //=> 'bar' console . log ( headers2 [ \"x-lorem\" ]); //=> 'impsum' Note: Handlers can be asynchronous and can return a Promise , but never a Promise<Stream> if options.isStream is true . Streams must always be handled synchronously. In order to perform async work using streams, the beforeRequest hook should be used instead. The recommended approach for creating handlers that can handle both promises and streams is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import got from \"got\" ; // Create a non-async handler, but we can return a Promise later. const handler = ( options , next ) => { if ( options . isStream ) { // It's a Stream, return synchronously. return next ( options ); } // For asynchronous work, return a Promise. return ( async () => { try { const response = await next ( options ); response . yourOwnProperty = true ; return response ; } catch ( error ) { // Every error will be replaced by this one. // Before you receive any error here, // it will be passed to the `beforeError` hooks first. // Note: this one won't be passed to `beforeError` hook. It's final. throw new Error ( \"Your very own error.\" ); } })(); }; const instance = got . extend ({ handlers : [ handler ] });","title":"got.extend(\u2026options, \u2026instances)"},{"location":"2-options/","text":"\u9009\u9879 \u00b6 Source code: source/core/options.ts Like fetch stores the options in a Request instance, Got does so in Options . It is made of getters and setters that provide fast option normalization and validation. By default, Got will retry on failure. To disable this option, set options.retry to {limit: 0} . \u5408\u5e76\u884c\u4e3a\u89e3\u91ca \u00b6 When an option is already set, setting it again replaces it with a deep clone by default. Otherwise the merge behavior is documented in the corresponding section for the option. \u5982\u4f55\u5b58\u50a8\u9009\u9879 \u00b6 The constructor - new Options(url, options, defaults) - takes the same arguments like the got function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got , { Options } from \"got\" ; const options = new Options ({ prefixUrl : \"https://httpbin.org\" , headers : { foo : \"foo\" , }, }); options . headers . foo = \"bar\" ; // Note that `Options` stores normalized options, therefore it needs to be passed as the third argument. const { headers } = await got ( \"anything\" , undefined , options ). json (); console . log ( headers . Foo ); //=> 'bar' If a plain object is preferred, it can be used in the following way: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; const options = { prefixUrl : \"https://httpbin.org\" , headers : { foo : \"bar\" , }, }; options . headers . foo = \"bar\" ; // Note that `options` is a plain object, therefore it needs to be passed as the second argument. const { headers } = await got ( \"anything\" , options ). json (); console . log ( headers . Foo ); //=> 'bar' Note that the constructor throws when an invalid option is provided, such as non-existing option or a typo. In the second example, it would throw only when the promise is being executed. For TypeScript users, got exports a dedicated type called OptionsInit . It is a plain object that can store the same properties as Options . Performance-wise there is no difference which one is used, although the constructor may be preferred as it automatically validates the data. The Options approach may give a slight boost as it only clones the options, there is no normalization going on. It is also useful for storing the base configuration of a custom Got client. \u91cd\u7f6e\u9009\u9879 \u00b6 Unlike Got 11, explicitly specifying undefined no longer keeps the parent value. In order to keep the parent value, you must not set an option to undefined . Doing so will reset those values: 1 2 3 4 5 6 7 8 9 10 instance ( \u2026 , { searchParams : undefined }}); instance ( \u2026 , { cookieJar : undefined }}); instance ( \u2026 , { responseType : undefined }}); instance ( \u2026 , { prefixUrl : '' }); instance ( \u2026 , { agent : { http : undefined , https : undefined , http2 : undefined }}); instance ( \u2026 , { context : { token : undefined , \u2026 }}); instance ( \u2026 , { https : { rejectUnauthorized : undefined , \u2026 }}); instance ( \u2026 , { cacheOptions : { immutableMinTimeToLive : undefined , \u2026 }}); instance ( \u2026 , { headers : { 'user-agent' : undefined , \u2026 }}); instance ( \u2026 , { timeout : { request : undefined , \u2026 }}); In order to reset hooks , retry and pagination , another Got instance must be created: 1 2 3 4 5 6 const defaults = new Options (); const secondInstance = instance . extend ({ mutableDefaults : true }); secondInstance . defaults . options . hooks = defaults . hooks ; secondInstance . defaults . options . retry = defaults . retry ; secondInstance . defaults . options . pagination = defaults . pagination ; url \u00b6 \u7c7b\u578b: string | URL The URL to request. Usually the url represents a WHATWG URL . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; // This: await got ( \"https://httpbin.org/anything\" ); // is semantically the same as this: await got ( new URL ( \"https://httpbin.org/anything\" )); // as well as this: await got ({ url : \"https://httpbin.org/anything\" , }); Note Throws if no protocol specified. Note If url is a string, then the query string will not be parsed as search params. This is in accordance to the specification . If you want to pass search params instead, use the searchParams option below. 1 2 3 4 5 6 7 import got from \"got\" ; await got ( \"https://httpbin.org/anything?query=a b\" ); //=> ?query=a%20b await got ( \"https://httpbin.org/anything\" , { searchParams : { query : \"a b\" } }); //=> ?query=a+b // The query string is overridden by `searchParams` await got ( \"https://httpbin.org/anything?query=a b\" , { searchParams : { query : \"a b\" } }); //=> ?query=a+b Note Leading slashes are disallowed to enforce consistency and avoid confusion. For example, when the prefix URL is https://example.com/foo and the input is /bar , there's ambiguity whether the resulting URL would become https://example.com/foo/bar or https://example.com/bar . The latter is used by browsers. searchParams \u00b6 \u7c7b\u578b: string | URLSearchParams | object<string, Primitive > WHATWG URL Search Params to be added to the request URL. 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const response = await got ( \"https://httpbin.org/anything\" , { searchParams : { hello : \"world\" , foo : 123 , }, }). json (); console . log ( response . args ); //=> {hello: 'world', foo: 123} If you need to pass an array, you can do it using a URLSearchParams instance: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const searchParams = new URLSearchParams ([ [ \"key\" , \"a\" ], [ \"key\" , \"b\" ], ]); await got ( \"https://httpbin.org/anything\" , { searchParams }); console . log ( searchParams . toString ()); //=> 'key=a&key=b' Note This will override the query string in url . Note null values are not stringified, an empty string is used instead. undefined values will clear the original keys. \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002 prefixUrl \u00b6 \u7c7b\u578b: string \u9ed8\u8ba4: '' The string to be prepended to url . The prefix can be any valid URL, either relative or absolute . A trailing slash / is optional - one will be added automatically. 1 2 3 4 5 6 7 8 import got from \"got\" ; // This: const instance = got . extend ({ prefixUrl : \"https://httpbin.org\" }); await instance ( \"anything\" ); // is semantically the same as this: await got ( \"https://httpbin.org/anything\" ); Note Changing prefixUrl also updates the url option if set. Note If you're passing an absolute URL as url , you need to set prefixUrl to an empty string. signal \u00b6 \u7c7b\u578b: AbortSignal You can abort the request using AbortController . Requires Node.js 16 or later. 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const abortController = new AbortController (); const request = got ( \"https://httpbin.org/anything\" , { signal : abortController . signal , }); setTimeout (() => { abortController . abort (); }, 100 ); method \u00b6 \u7c7b\u578b: string \u9ed8\u8ba4: GET The HTTP method used to make the request. The most common methods are: GET , HEAD , POST , PUT , DELETE . 1 2 3 4 5 6 7 8 import got from \"got\" ; const { method } = await got ( \"https://httpbin.org/anything\" , { method : \"POST\" , }). json (); console . log ( method ); // => 'POST' headers \u00b6 \u7c7b\u578b: object<string, string> \u9ed8\u8ba4: {} The HTTP headers to be sent. Headers set to undefined will be omitted. 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { headers } = await got . post ( \"https://httpbin.org/anything\" , { headers : { hello : \"world\" , }, }) . json (); console . log ( headers ); // => {hello: 'world'} \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002 isStream \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Whether the got function should return a Request duplex stream or a Promise<Response> . 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; // This: const stream = got ( \"https://httpbin.org/anything\" , { isStream : true }); // is semantically the same as this: const stream = got . stream ( \"https://httpbin.org/anything\" ); stream . setEncoding ( \"utf8\" ); stream . on ( \"data\" , console . log ); body \u00b6 \u7c7b\u578b: string | Buffer | stream.Readable | Generator | AsyncGenerator | FormData or form-data instance \u8981\u53d1\u9001\u7684\u6709\u6548\u8f7d\u8377\u3002 \u5bf9\u4e8e string \u548c Buffer \u7c7b\u578b\uff0c\u5982\u679c content-length \u548c transfer-encoding \u5934\u7f3a\u5931\uff0c content-length \u5934\u5c06\u81ea\u52a8\u8bbe\u7f6e\u3002 \u4eceGot 12\u5f00\u59cb\uff0c\u5f53 body \u662f fs.createReadStream() \u7684\u5b9e\u4f8b\u65f6\uff0c content-length \u5934\u4e0d\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u3002. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { body : \"Hello, world!\" , }) . json (); console . log ( data ); //=> 'Hello, world!' \u4eceGot 12\u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u7b26\u5408\u89c4\u8303\u7684 FormData \u5bf9\u8c61\u4f5c\u4e3a\u8bf7\u6c42\u4f53\uff0c\u4f8b\u5982 formdata-node \u6216 formdata-polyfill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; import { FormData } from \"formdata-node\" ; // or: // import {FormData} from 'formdata-polyfill/esm.min.js'; const form = new FormData (); form . set ( \"greeting\" , \"Hello, world!\" ); const data = await got . post ( \"https://httpbin.org/post\" , { body : form , }) . json (); console . log ( data . form . greeting ); //=> 'Hello, world!' Note \u5982\u679c\u6307\u5b9a\u4e86 body \uff0c\u5219\u4e0d\u80fd\u4f7f\u7528 json \u6216 form \u9009\u9879\u3002 Note \u5982\u679c\u4f7f\u7528\u6b64\u9009\u9879\uff0c got.stream() \u5c06\u662f\u53ea\u8bfb\u7684\u3002 Note \u9664\u975e allowGetBody \u9009\u9879 \u8bbe\u7f6e\u4e3a true \uff0c\u5426\u5219\u7528 GET \u4f20\u9012 body \u5c06\u629b\u51fa\u3002 Note \u6b64\u9009\u9879\u4e0d\u53ef\u679a\u4e3e\uff0c\u5e76\u4e14\u4e0d\u4f1a\u4e0e\u5b9e\u4f8b\u9ed8\u8ba4\u503c\u5408\u5e76\u3002 json \u00b6 \u7c7b\u578b: JSON-serializable values JSON body. \u5982\u679c\u8bbe\u7f6e\uff0c content-type \u5934\u9ed8\u8ba4\u4e3a application/json \u3002 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { json : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> `{hello: 'world'}` form \u00b6 \u7c7b\u578b: object<string, Primitive > \u4f7f\u7528 (new URLSearchParams(form)).toString() \u5c06\u8868\u5355\u4e3b\u4f53\u8f6c\u6362\u4e3a\u67e5\u8be2\u5b57\u7b26\u4e32. \u5982\u679c\u8bbe\u7f6e\u4e86\uff0c content-type \u5934\u9ed8\u8ba4\u4e3a application/x-www-form-urlencoded . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { form : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> 'hello=world' parseJson \u00b6 \u7c7b\u578b: (text: string) => unknown \u9ed8\u8ba4: (text: string) => JSON.parse(text) \u7528\u4e8e\u89e3\u6790JSON\u54cd\u5e94\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 import got from \"got\" ; import Bourne from \"@hapi/bourne\" ; // Preventing prototype pollution by using Bourne const parsed = await got ( \"https://example.com\" , { parseJson : ( text ) => Bourne . parse ( text ), }). json (); console . log ( parsed ); stringifyJson \u00b6 \u7c7b\u578b: (object: unknown) => string \u9ed8\u8ba4: (object: unknown) => JSON.stringify(object) \u7528\u4e8e\u5bf9JSON\u8bf7\u6c42\u4f53\u8fdb\u884c\u5b57\u7b26\u4e32\u5316\u7684\u51fd\u6570\u3002 \u4f8b\u5982:\u5ffd\u7565\u6240\u6709\u4ee5\u4e0b\u5212\u7ebf\u5f00\u5934\u7684\u5c5e\u6027 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; await got . post ( \"https://example.com\" , { stringifyJson : ( object ) => JSON . stringify ( object , ( key , value ) => { if ( key . startsWith ( \"_\" )) { return ; } return value ; }), json : { some : \"payload\" , _ignoreMe : 1234 , }, }); \u4f8b\u5982:\u6240\u6709\u6570\u5b57\u90fd\u662f\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; await got . post ( \"https://example.com\" , { stringifyJson : ( object ) => JSON . stringify ( object , ( key , value ) => { if ( typeof value === \"number\" ) { return value . toString (); } return value ; }), json : { some : \"payload\" , number : 1 , }, }); allowGetBody \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false \u5c06\u6b64\u8bbe\u7f6e\u4e3a true \u4ee5\u5141\u8bb8\u4e3a GET \u65b9\u6cd5\u53d1\u9001\u6b63\u6587\u3002 \u7136\u800c\uff0c HTTP/2\u89c4\u8303 \u8bf4: HTTP GET\u8bf7\u6c42\u5305\u62ec\u8bf7\u6c42\u5934\u5b57\u6bb5\uff0c\u6ca1\u6709\u6709\u6548\u8d1f\u8f7d\u4e3b\u4f53 \u56e0\u6b64\uff0c\u8be5\u9009\u9879\u5728\u4f7f\u7528HTTP/2\u65f6\u65e0\u6548\u3002 Note \u6b64\u9009\u9879\u4ec5\u7528\u4e8e\u5728\u6ca1\u6709\u5176\u4ed6\u9009\u62e9\u65f6\u4e0e\u4e0d\u517c\u5bb9\u7684\u670d\u52a1\u5668\u4ea4\u4e92\u3002 Note RFC 7231 \u6ca1\u6709\u4e3a\u5177\u6709\u6709\u6548\u8d1f\u8f7d\u7684GET\u65b9\u6cd5\u6307\u5b9a\u4efb\u4f55\u7279\u5b9a\u884c\u4e3a\uff0c\u56e0\u6b64\u5b83\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a \u53cd\u6a21\u5f0f \u3002 timeout \u00b6 \u7c7b\u578b: object See the Timeout API . \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002 retry \u00b6 \u7c7b\u578b: object See the Retry API . \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002 hooks \u00b6 \u7c7b\u578b: object See the Hooks API . \u5408\u5e76\u884c\u4e3a Merges arrays via [...hooksArray, ...next] encoding \u00b6 \u7c7b\u578b: string \u9ed8\u8ba4: 'utf8' Encoding to be used on setEncoding of the response data. To get a Buffer , you need to set responseType to 'buffer' instead. Don't set this option to null . 1 2 3 4 5 6 7 8 import got from \"got\" ; const response = await got ( \"https://httpbin.org/anything\" , { encoding : \"base64\" , }). text (); console . log ( response ); //=> base64 string Note This option does not affect streams! Instead, do: 1 2 3 4 5 6 import got from \"got\" ; const stream = got . stream ( \"https://httpbin.org/anything\" ); stream . setEncoding ( \"base64\" ); stream . on ( \"data\" , console . log ); responseType \u00b6 \u7c7b\u578b: 'text' | 'json' | 'buffer' \u9ed8\u8ba4: 'text' The parsing method. The promise also has .text() , .json() and .buffer() methods which return another Got promise for the parsed body. It's like setting the options to {responseType: 'json', resolveBodyOnly: true} but without affecting the main Got promise. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const responsePromise = got ( \"https://httpbin.org/anything\" ); const bufferPromise = responsePromise . buffer (); const jsonPromise = responsePromise . json (); const [ response , buffer , json ] = await Promise . all ([ responsePromise , bufferPromise , jsonPromise ]); // `response` is an instance of Got Response // `buffer` is an instance of Buffer // `json` is an object Note When using streams, this option is ignored. Note 'buffer' will return the raw body buffer. Any modifications will also alter the result of .text() and .json() . Before overwriting the buffer, please copy it first via Buffer.from(buffer) . See https://github.com/nodejs/node/issues/27080 resolveBodyOnly \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false If true , the promise will return the Response body instead of the Response object . 1 2 3 4 5 6 7 8 9 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; // This: const body = await got ( url ). json (); // is semantically the same as this: const body = await got ( url , { responseType : \"json\" , resolveBodyOnly : true }); context \u00b6 \u7c7b\u578b: object<string, unknown> \u9ed8\u8ba4: {} Note \u5185\u90e8\u7684\u4e0d\u53ef\u679a\u4e3e\u5c5e\u6027**\u6ca1\u6709**\u5408\u5e76\u3002 \u5305\u542b\u7528\u6237\u6570\u636e\u3002\u5b83\u5bf9\u4e8e\u5b58\u50a8\u8ba4\u8bc1\u4ee4\u724c\u975e\u5e38\u6709\u7528: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import got from \"got\" ; const instance = got . extend ({ hooks : { beforeRequest : [ ( options ) => { if ( typeof options . context . token !== \"string\" ) { throw new Error ( \"Token required\" ); } options . headers . token = options . context . token ; }, ], }, }); const context = { token : \"secret\" , }; const { headers } = await instance ( \"https://httpbin.org/headers\" , { context }). json (); console . log ( headers ); //=> {token: 'secret', \u2026} \u8fd9\u4e2a\u9009\u9879\u662f\u53ef\u679a\u4e3e\u7684\u3002\u4e3a\u4e86\u5728\u5185\u90e8\u5b9a\u4e49\u4e0d\u53ef\u679a\u4e3e\u7684\u5c5e\u6027\uff0c\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import got from \"got\" ; const context = {}; Object . defineProperties ( context , { token : { value : \"secret\" , enumerable : false , configurable : true , writable : true , }, }); const instance = got . extend ({ context }); console . log ( instance . defaults . options . context ); //=> {} \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002 cookieJar \u00b6 \u7c7b\u578b: object | tough.cookieJar Note \u8bbe\u7f6e\u6b64\u9009\u9879\u5c06\u5bfc\u81f4 cookie \u62a5\u5934\u88ab\u8986\u76d6\u3002 Cookie\u7684\u652f\u6301\u3002\u81ea\u52a8\u5904\u7406\u89e3\u6790\u548c\u5b58\u50a8\u3002 1 2 3 4 5 6 7 import got from \"got\" ; import { CookieJar } from \"tough-cookie\" ; const cookieJar = new CookieJar (); await cookieJar . setCookie ( \"foo=bar\" , \"https://example.com\" ); await got ( \"https://example.com\" , { cookieJar }); cookieJar.setCookie \u00b6 \u7c7b\u578b: (rawCookie: string, url: string) => void | Promise<void> See ToughCookie API for more information. cookieJar.getCookieString \u00b6 \u7c7b\u578b: (currentUrl: string) => string | Promise<string> See ToughCookie API for more information. ignoreInvalidCookies \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Ignore invalid cookies instead of throwing an error. Only useful when the cookieJar option has been set. Note This is not recommended! Use at your own risk. followRedirect \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true Defines if redirect responses should be followed automatically. Note If a 303 is sent by the server in response to any request type (POST, DELETE, etc.), Got will request the resource pointed to in the location header via GET. This is in accordance with the specification . You can optionally turn on this behavior also for other redirect codes - see methodRewriting . 1 2 3 4 5 6 7 8 import got from \"got\" ; const instance = got . extend ({ followRedirect : false }); const response = await instance ( \"http://google.com\" ); console . log ( response . headers . location ); //=> 'https://google.com' maxRedirects \u00b6 \u7c7b\u578b: number \u9ed8\u8ba4: 10 If exceeded, the request will be aborted and a MaxRedirectsError will be thrown. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const instance = got . extend ({ maxRedirects : 3 }); try { await instance ( \"https://nghttp2.org/httpbin/absolute-redirect/5\" ); } catch ( error ) { //=> 'Redirected 3 times. Aborting.' console . log ( error . message ); } decompress \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true Decompress the response automatically. This will set the accept-encoding header to gzip, deflate, br . If disabled, a compressed response is returned as a Buffer . This may be useful if you want to handle decompression yourself. 1 2 3 4 5 6 import got from \"got\" ; const response = await got ( \"https://google.com\" ); console . log ( response . headers [ \"content-encoding\" ]); //=> 'gzip' dnsLookup \u00b6 \u7c7b\u578b: Function \u9ed8\u8ba4: dns.lookup Custom DNS resolution logic. The function signature is the same as dns.lookup . dnsCache \u00b6 \u7c7b\u578b: CacheableLookup | false An instance of CacheableLookup used for making DNS lookups. Useful when making lots of requests to different public hostnames. Note This should stay disabled when making requests to internal hostnames such as localhost, database.local etc. CacheableLookup uses dns.resolver4(\u2026) and dns.resolver6(\u2026) under the hood and falls back to dns.lookup(\u2026) when the first two fail, which may lead to additional delay. dnsLookupIpVersion \u00b6 \u7c7b\u578b: 4 | 6 \u9ed8\u8ba4: undefined The IP version to use. Specifying undefined will use the default configuration. request \u00b6 \u7c7b\u578b: Function< ClientRequest | IncomingMessage > | AsyncFunction< ClientRequest | IncomingMessage > \u9ed8\u8ba4: http.request | https.request (depending on the protocol) Custom request function. The main purpose of this is to support HTTP/2 using a wrapper . cache \u00b6 \u7c7b\u578b: object | false \u9ed8\u8ba4: false Cache adapter instance for storing cached response data. cacheOptions \u00b6 \u7c7b\u578b: object \u9ed8\u8ba4: {} Cache options used for the specified request. http2 \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Note This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy. If true , the request option will default to http2wrapper.auto and the entire agent object will be passed. Note ALPN negotiation will have place in order to determine if the server actually supports HTTP/2. If it doesn't, HTTP/1.1 will be used. Note Setting the request option to https.request will disable HTTP/2 usage. It is required to use http2wrapper.auto . Note There is no direct h2c support. However, you can provide a h2session option in a beforeRequest hook. See an example . 1 2 3 4 5 6 7 8 import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { http2 : true , }); console . log ( headers [ \":status\" ]); //=> 200 Note The current Got version may use an older version of http2-wrapper . If you prefer to use the newest one, set both request to http2wrapper.auto and http2 to true . 1 2 3 4 5 6 7 8 9 10 import http2wrapper from \"http2-wrapper\" ; import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { http2 : true , request : http2wrapper . auto , }); console . log ( headers [ \":status\" ]); //=> 200 See the http2-wrapper docs to learn more about Agent and Proxy support. agent \u00b6 \u7c7b\u578b: object \u9ed8\u8ba4: {} An object with http , https and http2 properties. Got will automatically resolve the protocol and use the corresponding agent. It defaults to: 1 2 3 4 5 { http : http . globalAgent , https : https . globalAgent , http2 : http2 . globalAgent } Note The HTTP/2 Agent must be an instance of http2wrapper.Agent throwHttpErrors \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true If true , it will throw when the status code is not 2xx / 3xx . If this is disabled, requests that encounter an error status code will be resolved with the response instead of throwing. This may be useful if you are checking for resource availability and are expecting error responses. username \u00b6 \u7c7b\u578b: string \u9ed8\u8ba4: '' The username used for Basic authentication . password \u00b6 \u7c7b\u578b: string \u9ed8\u8ba4: '' The password used for Basic authentication . localAddress \u00b6 \u7c7b\u578b: string | undefined \u9ed8\u8ba4: undefined The local IP address used to make the request. createConnection \u00b6 \u7c7b\u578b: Function | undefined \u9ed8\u8ba4: undefined The function used to retrieve a net.Socket instance when the agent option is not used. https \u00b6 \u7c7b\u578b: object See Advanced HTTPS API . pagination \u00b6 \u7c7b\u578b: object See Pagination API . setHost \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true Specifies whether or not to automatically add the Host header. maxHeaderSize \u00b6 \u7c7b\u578b: number | undefined \u9ed8\u8ba4: undefined Optionally overrides the value of --max-http-header-size (default 16KB: 16384 ). methodRewriting \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Specifies if the HTTP request method should be rewritten as GET on redirects. As the specification prefers to rewrite the HTTP method only on 303 responses, this is Got's default behavior. Setting methodRewriting to true will also rewrite 301 and 302 responses, as allowed by the spec. This is the behavior followed by curl and browsers. Note Got never performs method rewriting on 307 and 308 responses, as this is explicitly prohibited by the specification . enableUnixSockets \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true When enabled, requests can also be sent via UNIX Domain Sockets . Please note that in the upcoming major release (Got v13) this default will be changed to false for security reasons. Warning Make sure you do your own URL sanitizing if you accept untrusted user input for the URL. Use the following URL scheme: PROTOCOL://unix:SOCKET:PATH PROTOCOL - http or https SOCKET - Absolute path to a UNIX domain socket, for example: /var/run/docker.sock PATH - Request path, for example: /v2/keys 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; await got ( \"http://unix:/var/run/docker.sock:/containers/json\" , { enableUnixSockets : true }); // Or without protocol (HTTP by default) await got ( \"unix:/var/run/docker.sock:/containers/json\" , { enableUnixSockets : true }); // Disable Unix sockets const gotUnixSocketsDisabled = got . extend ({ enableUnixSockets : false }); // RequestError: Using UNIX domain sockets but option `enableUnixSockets` is not enabled await gotUnixSocketsDisabled ( \"http://unix:/var/run/docker.sock:/containers/json\" ); Methods \u00b6 options.merge(other: Options | OptionsInit) \u00b6 Merges other into the current instance. If you look at the source code , you will notice that internally there is a this._merging property. Setters work a bit differently when it's true . options.toJSON() \u00b6 Returns a new plain object that can be stored as JSON . options.createNativeRequestOptions() \u00b6 Creates a new object for native Node.js HTTP request options. In other words, this translates Got options into Node.js options. Note Some other stuff, such as timeouts, is handled internally by Got. options.getRequestFunction() \u00b6 Returns a http.request -like function used to make the request. options.freeze() \u00b6 Makes the entire Options instance read-only.","title":"\u9009\u9879"},{"location":"2-options/#_1","text":"Source code: source/core/options.ts Like fetch stores the options in a Request instance, Got does so in Options . It is made of getters and setters that provide fast option normalization and validation. By default, Got will retry on failure. To disable this option, set options.retry to {limit: 0} .","title":"\u9009\u9879"},{"location":"2-options/#_2","text":"When an option is already set, setting it again replaces it with a deep clone by default. Otherwise the merge behavior is documented in the corresponding section for the option.","title":"\u5408\u5e76\u884c\u4e3a\u89e3\u91ca"},{"location":"2-options/#_3","text":"The constructor - new Options(url, options, defaults) - takes the same arguments like the got function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got , { Options } from \"got\" ; const options = new Options ({ prefixUrl : \"https://httpbin.org\" , headers : { foo : \"foo\" , }, }); options . headers . foo = \"bar\" ; // Note that `Options` stores normalized options, therefore it needs to be passed as the third argument. const { headers } = await got ( \"anything\" , undefined , options ). json (); console . log ( headers . Foo ); //=> 'bar' If a plain object is preferred, it can be used in the following way: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; const options = { prefixUrl : \"https://httpbin.org\" , headers : { foo : \"bar\" , }, }; options . headers . foo = \"bar\" ; // Note that `options` is a plain object, therefore it needs to be passed as the second argument. const { headers } = await got ( \"anything\" , options ). json (); console . log ( headers . Foo ); //=> 'bar' Note that the constructor throws when an invalid option is provided, such as non-existing option or a typo. In the second example, it would throw only when the promise is being executed. For TypeScript users, got exports a dedicated type called OptionsInit . It is a plain object that can store the same properties as Options . Performance-wise there is no difference which one is used, although the constructor may be preferred as it automatically validates the data. The Options approach may give a slight boost as it only clones the options, there is no normalization going on. It is also useful for storing the base configuration of a custom Got client.","title":"\u5982\u4f55\u5b58\u50a8\u9009\u9879"},{"location":"2-options/#_4","text":"Unlike Got 11, explicitly specifying undefined no longer keeps the parent value. In order to keep the parent value, you must not set an option to undefined . Doing so will reset those values: 1 2 3 4 5 6 7 8 9 10 instance ( \u2026 , { searchParams : undefined }}); instance ( \u2026 , { cookieJar : undefined }}); instance ( \u2026 , { responseType : undefined }}); instance ( \u2026 , { prefixUrl : '' }); instance ( \u2026 , { agent : { http : undefined , https : undefined , http2 : undefined }}); instance ( \u2026 , { context : { token : undefined , \u2026 }}); instance ( \u2026 , { https : { rejectUnauthorized : undefined , \u2026 }}); instance ( \u2026 , { cacheOptions : { immutableMinTimeToLive : undefined , \u2026 }}); instance ( \u2026 , { headers : { 'user-agent' : undefined , \u2026 }}); instance ( \u2026 , { timeout : { request : undefined , \u2026 }}); In order to reset hooks , retry and pagination , another Got instance must be created: 1 2 3 4 5 6 const defaults = new Options (); const secondInstance = instance . extend ({ mutableDefaults : true }); secondInstance . defaults . options . hooks = defaults . hooks ; secondInstance . defaults . options . retry = defaults . retry ; secondInstance . defaults . options . pagination = defaults . pagination ;","title":"\u91cd\u7f6e\u9009\u9879"},{"location":"2-options/#url","text":"\u7c7b\u578b: string | URL The URL to request. Usually the url represents a WHATWG URL . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; // This: await got ( \"https://httpbin.org/anything\" ); // is semantically the same as this: await got ( new URL ( \"https://httpbin.org/anything\" )); // as well as this: await got ({ url : \"https://httpbin.org/anything\" , }); Note Throws if no protocol specified. Note If url is a string, then the query string will not be parsed as search params. This is in accordance to the specification . If you want to pass search params instead, use the searchParams option below. 1 2 3 4 5 6 7 import got from \"got\" ; await got ( \"https://httpbin.org/anything?query=a b\" ); //=> ?query=a%20b await got ( \"https://httpbin.org/anything\" , { searchParams : { query : \"a b\" } }); //=> ?query=a+b // The query string is overridden by `searchParams` await got ( \"https://httpbin.org/anything?query=a b\" , { searchParams : { query : \"a b\" } }); //=> ?query=a+b Note Leading slashes are disallowed to enforce consistency and avoid confusion. For example, when the prefix URL is https://example.com/foo and the input is /bar , there's ambiguity whether the resulting URL would become https://example.com/foo/bar or https://example.com/bar . The latter is used by browsers.","title":"url"},{"location":"2-options/#searchparams","text":"\u7c7b\u578b: string | URLSearchParams | object<string, Primitive > WHATWG URL Search Params to be added to the request URL. 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const response = await got ( \"https://httpbin.org/anything\" , { searchParams : { hello : \"world\" , foo : 123 , }, }). json (); console . log ( response . args ); //=> {hello: 'world', foo: 123} If you need to pass an array, you can do it using a URLSearchParams instance: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const searchParams = new URLSearchParams ([ [ \"key\" , \"a\" ], [ \"key\" , \"b\" ], ]); await got ( \"https://httpbin.org/anything\" , { searchParams }); console . log ( searchParams . toString ()); //=> 'key=a&key=b' Note This will override the query string in url . Note null values are not stringified, an empty string is used instead. undefined values will clear the original keys. \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002","title":"searchParams"},{"location":"2-options/#prefixurl","text":"\u7c7b\u578b: string \u9ed8\u8ba4: '' The string to be prepended to url . The prefix can be any valid URL, either relative or absolute . A trailing slash / is optional - one will be added automatically. 1 2 3 4 5 6 7 8 import got from \"got\" ; // This: const instance = got . extend ({ prefixUrl : \"https://httpbin.org\" }); await instance ( \"anything\" ); // is semantically the same as this: await got ( \"https://httpbin.org/anything\" ); Note Changing prefixUrl also updates the url option if set. Note If you're passing an absolute URL as url , you need to set prefixUrl to an empty string.","title":"prefixUrl"},{"location":"2-options/#signal","text":"\u7c7b\u578b: AbortSignal You can abort the request using AbortController . Requires Node.js 16 or later. 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const abortController = new AbortController (); const request = got ( \"https://httpbin.org/anything\" , { signal : abortController . signal , }); setTimeout (() => { abortController . abort (); }, 100 );","title":"signal"},{"location":"2-options/#method","text":"\u7c7b\u578b: string \u9ed8\u8ba4: GET The HTTP method used to make the request. The most common methods are: GET , HEAD , POST , PUT , DELETE . 1 2 3 4 5 6 7 8 import got from \"got\" ; const { method } = await got ( \"https://httpbin.org/anything\" , { method : \"POST\" , }). json (); console . log ( method ); // => 'POST'","title":"method"},{"location":"2-options/#headers","text":"\u7c7b\u578b: object<string, string> \u9ed8\u8ba4: {} The HTTP headers to be sent. Headers set to undefined will be omitted. 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { headers } = await got . post ( \"https://httpbin.org/anything\" , { headers : { hello : \"world\" , }, }) . json (); console . log ( headers ); // => {hello: 'world'} \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002","title":"headers"},{"location":"2-options/#isstream","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Whether the got function should return a Request duplex stream or a Promise<Response> . 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; // This: const stream = got ( \"https://httpbin.org/anything\" , { isStream : true }); // is semantically the same as this: const stream = got . stream ( \"https://httpbin.org/anything\" ); stream . setEncoding ( \"utf8\" ); stream . on ( \"data\" , console . log );","title":"isStream"},{"location":"2-options/#body","text":"\u7c7b\u578b: string | Buffer | stream.Readable | Generator | AsyncGenerator | FormData or form-data instance \u8981\u53d1\u9001\u7684\u6709\u6548\u8f7d\u8377\u3002 \u5bf9\u4e8e string \u548c Buffer \u7c7b\u578b\uff0c\u5982\u679c content-length \u548c transfer-encoding \u5934\u7f3a\u5931\uff0c content-length \u5934\u5c06\u81ea\u52a8\u8bbe\u7f6e\u3002 \u4eceGot 12\u5f00\u59cb\uff0c\u5f53 body \u662f fs.createReadStream() \u7684\u5b9e\u4f8b\u65f6\uff0c content-length \u5934\u4e0d\u4f1a\u81ea\u52a8\u8bbe\u7f6e\u3002. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { body : \"Hello, world!\" , }) . json (); console . log ( data ); //=> 'Hello, world!' \u4eceGot 12\u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u7b26\u5408\u89c4\u8303\u7684 FormData \u5bf9\u8c61\u4f5c\u4e3a\u8bf7\u6c42\u4f53\uff0c\u4f8b\u5982 formdata-node \u6216 formdata-polyfill : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; import { FormData } from \"formdata-node\" ; // or: // import {FormData} from 'formdata-polyfill/esm.min.js'; const form = new FormData (); form . set ( \"greeting\" , \"Hello, world!\" ); const data = await got . post ( \"https://httpbin.org/post\" , { body : form , }) . json (); console . log ( data . form . greeting ); //=> 'Hello, world!' Note \u5982\u679c\u6307\u5b9a\u4e86 body \uff0c\u5219\u4e0d\u80fd\u4f7f\u7528 json \u6216 form \u9009\u9879\u3002 Note \u5982\u679c\u4f7f\u7528\u6b64\u9009\u9879\uff0c got.stream() \u5c06\u662f\u53ea\u8bfb\u7684\u3002 Note \u9664\u975e allowGetBody \u9009\u9879 \u8bbe\u7f6e\u4e3a true \uff0c\u5426\u5219\u7528 GET \u4f20\u9012 body \u5c06\u629b\u51fa\u3002 Note \u6b64\u9009\u9879\u4e0d\u53ef\u679a\u4e3e\uff0c\u5e76\u4e14\u4e0d\u4f1a\u4e0e\u5b9e\u4f8b\u9ed8\u8ba4\u503c\u5408\u5e76\u3002","title":"body"},{"location":"2-options/#json","text":"\u7c7b\u578b: JSON-serializable values JSON body. \u5982\u679c\u8bbe\u7f6e\uff0c content-type \u5934\u9ed8\u8ba4\u4e3a application/json \u3002 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { json : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> `{hello: 'world'}`","title":"json"},{"location":"2-options/#form","text":"\u7c7b\u578b: object<string, Primitive > \u4f7f\u7528 (new URLSearchParams(form)).toString() \u5c06\u8868\u5355\u4e3b\u4f53\u8f6c\u6362\u4e3a\u67e5\u8be2\u5b57\u7b26\u4e32. \u5982\u679c\u8bbe\u7f6e\u4e86\uff0c content-type \u5934\u9ed8\u8ba4\u4e3a application/x-www-form-urlencoded . 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const { data } = await got . post ( \"https://httpbin.org/anything\" , { form : { hello : \"world\" , }, }) . json (); console . log ( data ); //=> 'hello=world'","title":"form"},{"location":"2-options/#parsejson","text":"\u7c7b\u578b: (text: string) => unknown \u9ed8\u8ba4: (text: string) => JSON.parse(text) \u7528\u4e8e\u89e3\u6790JSON\u54cd\u5e94\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 import got from \"got\" ; import Bourne from \"@hapi/bourne\" ; // Preventing prototype pollution by using Bourne const parsed = await got ( \"https://example.com\" , { parseJson : ( text ) => Bourne . parse ( text ), }). json (); console . log ( parsed );","title":"parseJson"},{"location":"2-options/#stringifyjson","text":"\u7c7b\u578b: (object: unknown) => string \u9ed8\u8ba4: (object: unknown) => JSON.stringify(object) \u7528\u4e8e\u5bf9JSON\u8bf7\u6c42\u4f53\u8fdb\u884c\u5b57\u7b26\u4e32\u5316\u7684\u51fd\u6570\u3002 \u4f8b\u5982:\u5ffd\u7565\u6240\u6709\u4ee5\u4e0b\u5212\u7ebf\u5f00\u5934\u7684\u5c5e\u6027 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; await got . post ( \"https://example.com\" , { stringifyJson : ( object ) => JSON . stringify ( object , ( key , value ) => { if ( key . startsWith ( \"_\" )) { return ; } return value ; }), json : { some : \"payload\" , _ignoreMe : 1234 , }, }); \u4f8b\u5982:\u6240\u6709\u6570\u5b57\u90fd\u662f\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; await got . post ( \"https://example.com\" , { stringifyJson : ( object ) => JSON . stringify ( object , ( key , value ) => { if ( typeof value === \"number\" ) { return value . toString (); } return value ; }), json : { some : \"payload\" , number : 1 , }, });","title":"stringifyJson"},{"location":"2-options/#allowgetbody","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false \u5c06\u6b64\u8bbe\u7f6e\u4e3a true \u4ee5\u5141\u8bb8\u4e3a GET \u65b9\u6cd5\u53d1\u9001\u6b63\u6587\u3002 \u7136\u800c\uff0c HTTP/2\u89c4\u8303 \u8bf4: HTTP GET\u8bf7\u6c42\u5305\u62ec\u8bf7\u6c42\u5934\u5b57\u6bb5\uff0c\u6ca1\u6709\u6709\u6548\u8d1f\u8f7d\u4e3b\u4f53 \u56e0\u6b64\uff0c\u8be5\u9009\u9879\u5728\u4f7f\u7528HTTP/2\u65f6\u65e0\u6548\u3002 Note \u6b64\u9009\u9879\u4ec5\u7528\u4e8e\u5728\u6ca1\u6709\u5176\u4ed6\u9009\u62e9\u65f6\u4e0e\u4e0d\u517c\u5bb9\u7684\u670d\u52a1\u5668\u4ea4\u4e92\u3002 Note RFC 7231 \u6ca1\u6709\u4e3a\u5177\u6709\u6709\u6548\u8d1f\u8f7d\u7684GET\u65b9\u6cd5\u6307\u5b9a\u4efb\u4f55\u7279\u5b9a\u884c\u4e3a\uff0c\u56e0\u6b64\u5b83\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a \u53cd\u6a21\u5f0f \u3002","title":"allowGetBody"},{"location":"2-options/#timeout","text":"\u7c7b\u578b: object See the Timeout API . \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002","title":"timeout"},{"location":"2-options/#retry","text":"\u7c7b\u578b: object See the Retry API . \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002","title":"retry"},{"location":"2-options/#hooks","text":"\u7c7b\u578b: object See the Hooks API . \u5408\u5e76\u884c\u4e3a Merges arrays via [...hooksArray, ...next]","title":"hooks"},{"location":"2-options/#encoding","text":"\u7c7b\u578b: string \u9ed8\u8ba4: 'utf8' Encoding to be used on setEncoding of the response data. To get a Buffer , you need to set responseType to 'buffer' instead. Don't set this option to null . 1 2 3 4 5 6 7 8 import got from \"got\" ; const response = await got ( \"https://httpbin.org/anything\" , { encoding : \"base64\" , }). text (); console . log ( response ); //=> base64 string Note This option does not affect streams! Instead, do: 1 2 3 4 5 6 import got from \"got\" ; const stream = got . stream ( \"https://httpbin.org/anything\" ); stream . setEncoding ( \"base64\" ); stream . on ( \"data\" , console . log );","title":"encoding"},{"location":"2-options/#responsetype","text":"\u7c7b\u578b: 'text' | 'json' | 'buffer' \u9ed8\u8ba4: 'text' The parsing method. The promise also has .text() , .json() and .buffer() methods which return another Got promise for the parsed body. It's like setting the options to {responseType: 'json', resolveBodyOnly: true} but without affecting the main Got promise. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const responsePromise = got ( \"https://httpbin.org/anything\" ); const bufferPromise = responsePromise . buffer (); const jsonPromise = responsePromise . json (); const [ response , buffer , json ] = await Promise . all ([ responsePromise , bufferPromise , jsonPromise ]); // `response` is an instance of Got Response // `buffer` is an instance of Buffer // `json` is an object Note When using streams, this option is ignored. Note 'buffer' will return the raw body buffer. Any modifications will also alter the result of .text() and .json() . Before overwriting the buffer, please copy it first via Buffer.from(buffer) . See https://github.com/nodejs/node/issues/27080","title":"responseType"},{"location":"2-options/#resolvebodyonly","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false If true , the promise will return the Response body instead of the Response object . 1 2 3 4 5 6 7 8 9 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; // This: const body = await got ( url ). json (); // is semantically the same as this: const body = await got ( url , { responseType : \"json\" , resolveBodyOnly : true });","title":"resolveBodyOnly"},{"location":"2-options/#context","text":"\u7c7b\u578b: object<string, unknown> \u9ed8\u8ba4: {} Note \u5185\u90e8\u7684\u4e0d\u53ef\u679a\u4e3e\u5c5e\u6027**\u6ca1\u6709**\u5408\u5e76\u3002 \u5305\u542b\u7528\u6237\u6570\u636e\u3002\u5b83\u5bf9\u4e8e\u5b58\u50a8\u8ba4\u8bc1\u4ee4\u724c\u975e\u5e38\u6709\u7528: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import got from \"got\" ; const instance = got . extend ({ hooks : { beforeRequest : [ ( options ) => { if ( typeof options . context . token !== \"string\" ) { throw new Error ( \"Token required\" ); } options . headers . token = options . context . token ; }, ], }, }); const context = { token : \"secret\" , }; const { headers } = await instance ( \"https://httpbin.org/headers\" , { context }). json (); console . log ( headers ); //=> {token: 'secret', \u2026} \u8fd9\u4e2a\u9009\u9879\u662f\u53ef\u679a\u4e3e\u7684\u3002\u4e3a\u4e86\u5728\u5185\u90e8\u5b9a\u4e49\u4e0d\u53ef\u679a\u4e3e\u7684\u5c5e\u6027\uff0c\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import got from \"got\" ; const context = {}; Object . defineProperties ( context , { token : { value : \"secret\" , enumerable : false , configurable : true , writable : true , }, }); const instance = got . extend ({ context }); console . log ( instance . defaults . options . context ); //=> {} \u5408\u5e76\u884c\u4e3a \u8986\u76d6\u73b0\u6709\u5c5e\u6027\u3002","title":"context"},{"location":"2-options/#cookiejar","text":"\u7c7b\u578b: object | tough.cookieJar Note \u8bbe\u7f6e\u6b64\u9009\u9879\u5c06\u5bfc\u81f4 cookie \u62a5\u5934\u88ab\u8986\u76d6\u3002 Cookie\u7684\u652f\u6301\u3002\u81ea\u52a8\u5904\u7406\u89e3\u6790\u548c\u5b58\u50a8\u3002 1 2 3 4 5 6 7 import got from \"got\" ; import { CookieJar } from \"tough-cookie\" ; const cookieJar = new CookieJar (); await cookieJar . setCookie ( \"foo=bar\" , \"https://example.com\" ); await got ( \"https://example.com\" , { cookieJar });","title":"cookieJar"},{"location":"2-options/#cookiejarsetcookie","text":"\u7c7b\u578b: (rawCookie: string, url: string) => void | Promise<void> See ToughCookie API for more information.","title":"cookieJar.setCookie"},{"location":"2-options/#cookiejargetcookiestring","text":"\u7c7b\u578b: (currentUrl: string) => string | Promise<string> See ToughCookie API for more information.","title":"cookieJar.getCookieString"},{"location":"2-options/#ignoreinvalidcookies","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Ignore invalid cookies instead of throwing an error. Only useful when the cookieJar option has been set. Note This is not recommended! Use at your own risk.","title":"ignoreInvalidCookies"},{"location":"2-options/#followredirect","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true Defines if redirect responses should be followed automatically. Note If a 303 is sent by the server in response to any request type (POST, DELETE, etc.), Got will request the resource pointed to in the location header via GET. This is in accordance with the specification . You can optionally turn on this behavior also for other redirect codes - see methodRewriting . 1 2 3 4 5 6 7 8 import got from \"got\" ; const instance = got . extend ({ followRedirect : false }); const response = await instance ( \"http://google.com\" ); console . log ( response . headers . location ); //=> 'https://google.com'","title":"followRedirect"},{"location":"2-options/#maxredirects","text":"\u7c7b\u578b: number \u9ed8\u8ba4: 10 If exceeded, the request will be aborted and a MaxRedirectsError will be thrown. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const instance = got . extend ({ maxRedirects : 3 }); try { await instance ( \"https://nghttp2.org/httpbin/absolute-redirect/5\" ); } catch ( error ) { //=> 'Redirected 3 times. Aborting.' console . log ( error . message ); }","title":"maxRedirects"},{"location":"2-options/#decompress","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true Decompress the response automatically. This will set the accept-encoding header to gzip, deflate, br . If disabled, a compressed response is returned as a Buffer . This may be useful if you want to handle decompression yourself. 1 2 3 4 5 6 import got from \"got\" ; const response = await got ( \"https://google.com\" ); console . log ( response . headers [ \"content-encoding\" ]); //=> 'gzip'","title":"decompress"},{"location":"2-options/#dnslookup","text":"\u7c7b\u578b: Function \u9ed8\u8ba4: dns.lookup Custom DNS resolution logic. The function signature is the same as dns.lookup .","title":"dnsLookup"},{"location":"2-options/#dnscache","text":"\u7c7b\u578b: CacheableLookup | false An instance of CacheableLookup used for making DNS lookups. Useful when making lots of requests to different public hostnames. Note This should stay disabled when making requests to internal hostnames such as localhost, database.local etc. CacheableLookup uses dns.resolver4(\u2026) and dns.resolver6(\u2026) under the hood and falls back to dns.lookup(\u2026) when the first two fail, which may lead to additional delay.","title":"dnsCache"},{"location":"2-options/#dnslookupipversion","text":"\u7c7b\u578b: 4 | 6 \u9ed8\u8ba4: undefined The IP version to use. Specifying undefined will use the default configuration.","title":"dnsLookupIpVersion"},{"location":"2-options/#request","text":"\u7c7b\u578b: Function< ClientRequest | IncomingMessage > | AsyncFunction< ClientRequest | IncomingMessage > \u9ed8\u8ba4: http.request | https.request (depending on the protocol) Custom request function. The main purpose of this is to support HTTP/2 using a wrapper .","title":"request"},{"location":"2-options/#cache","text":"\u7c7b\u578b: object | false \u9ed8\u8ba4: false Cache adapter instance for storing cached response data.","title":"cache"},{"location":"2-options/#cacheoptions","text":"\u7c7b\u578b: object \u9ed8\u8ba4: {} Cache options used for the specified request.","title":"cacheOptions"},{"location":"2-options/#http2","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Note This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy. If true , the request option will default to http2wrapper.auto and the entire agent object will be passed. Note ALPN negotiation will have place in order to determine if the server actually supports HTTP/2. If it doesn't, HTTP/1.1 will be used. Note Setting the request option to https.request will disable HTTP/2 usage. It is required to use http2wrapper.auto . Note There is no direct h2c support. However, you can provide a h2session option in a beforeRequest hook. See an example . 1 2 3 4 5 6 7 8 import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { http2 : true , }); console . log ( headers [ \":status\" ]); //=> 200 Note The current Got version may use an older version of http2-wrapper . If you prefer to use the newest one, set both request to http2wrapper.auto and http2 to true . 1 2 3 4 5 6 7 8 9 10 import http2wrapper from \"http2-wrapper\" ; import got from \"got\" ; const { headers } = await got ( \"https://httpbin.org/anything\" , { http2 : true , request : http2wrapper . auto , }); console . log ( headers [ \":status\" ]); //=> 200 See the http2-wrapper docs to learn more about Agent and Proxy support.","title":"http2"},{"location":"2-options/#agent","text":"\u7c7b\u578b: object \u9ed8\u8ba4: {} An object with http , https and http2 properties. Got will automatically resolve the protocol and use the corresponding agent. It defaults to: 1 2 3 4 5 { http : http . globalAgent , https : https . globalAgent , http2 : http2 . globalAgent } Note The HTTP/2 Agent must be an instance of http2wrapper.Agent","title":"agent"},{"location":"2-options/#throwhttperrors","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true If true , it will throw when the status code is not 2xx / 3xx . If this is disabled, requests that encounter an error status code will be resolved with the response instead of throwing. This may be useful if you are checking for resource availability and are expecting error responses.","title":"throwHttpErrors"},{"location":"2-options/#username","text":"\u7c7b\u578b: string \u9ed8\u8ba4: '' The username used for Basic authentication .","title":"username"},{"location":"2-options/#password","text":"\u7c7b\u578b: string \u9ed8\u8ba4: '' The password used for Basic authentication .","title":"password"},{"location":"2-options/#localaddress","text":"\u7c7b\u578b: string | undefined \u9ed8\u8ba4: undefined The local IP address used to make the request.","title":"localAddress"},{"location":"2-options/#createconnection","text":"\u7c7b\u578b: Function | undefined \u9ed8\u8ba4: undefined The function used to retrieve a net.Socket instance when the agent option is not used.","title":"createConnection"},{"location":"2-options/#https","text":"\u7c7b\u578b: object See Advanced HTTPS API .","title":"https"},{"location":"2-options/#pagination","text":"\u7c7b\u578b: object See Pagination API .","title":"pagination"},{"location":"2-options/#sethost","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true Specifies whether or not to automatically add the Host header.","title":"setHost"},{"location":"2-options/#maxheadersize","text":"\u7c7b\u578b: number | undefined \u9ed8\u8ba4: undefined Optionally overrides the value of --max-http-header-size (default 16KB: 16384 ).","title":"maxHeaderSize"},{"location":"2-options/#methodrewriting","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Specifies if the HTTP request method should be rewritten as GET on redirects. As the specification prefers to rewrite the HTTP method only on 303 responses, this is Got's default behavior. Setting methodRewriting to true will also rewrite 301 and 302 responses, as allowed by the spec. This is the behavior followed by curl and browsers. Note Got never performs method rewriting on 307 and 308 responses, as this is explicitly prohibited by the specification .","title":"methodRewriting"},{"location":"2-options/#enableunixsockets","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true When enabled, requests can also be sent via UNIX Domain Sockets . Please note that in the upcoming major release (Got v13) this default will be changed to false for security reasons. Warning Make sure you do your own URL sanitizing if you accept untrusted user input for the URL. Use the following URL scheme: PROTOCOL://unix:SOCKET:PATH PROTOCOL - http or https SOCKET - Absolute path to a UNIX domain socket, for example: /var/run/docker.sock PATH - Request path, for example: /v2/keys 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; await got ( \"http://unix:/var/run/docker.sock:/containers/json\" , { enableUnixSockets : true }); // Or without protocol (HTTP by default) await got ( \"unix:/var/run/docker.sock:/containers/json\" , { enableUnixSockets : true }); // Disable Unix sockets const gotUnixSocketsDisabled = got . extend ({ enableUnixSockets : false }); // RequestError: Using UNIX domain sockets but option `enableUnixSockets` is not enabled await gotUnixSocketsDisabled ( \"http://unix:/var/run/docker.sock:/containers/json\" );","title":"enableUnixSockets"},{"location":"2-options/#methods","text":"","title":"Methods"},{"location":"2-options/#optionsmergeother-options-optionsinit","text":"Merges other into the current instance. If you look at the source code , you will notice that internally there is a this._merging property. Setters work a bit differently when it's true .","title":"options.merge(other: Options | OptionsInit)"},{"location":"2-options/#optionstojson","text":"Returns a new plain object that can be stored as JSON .","title":"options.toJSON()"},{"location":"2-options/#optionscreatenativerequestoptions","text":"Creates a new object for native Node.js HTTP request options. In other words, this translates Got options into Node.js options. Note Some other stuff, such as timeouts, is handled internally by Got.","title":"options.createNativeRequestOptions()"},{"location":"2-options/#optionsgetrequestfunction","text":"Returns a http.request -like function used to make the request.","title":"options.getRequestFunction()"},{"location":"2-options/#optionsfreeze","text":"Makes the entire Options instance read-only.","title":"options.freeze()"},{"location":"3-streams/","text":"Stream API \u00b6 Source code: source/core/index.ts got.stream(url, options, defaults) \u00b6 got(url, {...options, isStream: true}, defaults) \u00b6 The two functions above are exposed by the got main interface and return a new instance of Request . new Request(url, options, defaults) \u00b6 Extends: Duplex stream This constructor takes the same arguments as the Got promise. Note: When piping to ServerResponse , the headers will be automatically copied. In order to prevent this behavior you need to override the request headers in a beforeRequest hook. Note: If the body , json or form option is used, this stream will be read-only. Note: While got.post('https://example.com') resolves, got.stream.post('https://example.com') will hang indefinitely until a body is provided. If there's no body on purpose, remember to stream.end() or set the body option to an empty string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { promisify } from \"node:util\" ; import stream from \"node:stream\" ; import fs from \"node:fs\" ; import got from \"got\" ; const pipeline = promisify ( stream . pipeline ); // This example streams the GET response of a URL to a file. await pipeline ( got . stream ( \"https://sindresorhus.com\" ), fs . createWriteStream ( \"index.html\" )); // For POST, PUT, PATCH, and DELETE methods, `got.stream` returns a `stream.Writable`. // This example POSTs the contents of a file to a URL. await pipeline ( fs . createReadStream ( \"index.html\" ), got . stream . post ( \"https://sindresorhus.com\" ), new stream . PassThrough () ); // In order to POST, PUT, PATCH, or DELETE without a request body, explicitly specify an empty body: await pipeline ( got . stream . post ( \"https://sindresorhus.com\" , { body : \"\" }), new stream . PassThrough ()); Please note that new stream.PassThrough() is required in order to catch read errors. If it was missing then pipeline wouldn't catch any read errors because there would be no stream to pipe to. In other words, it would only check errors when writing. Tip: Avoid from.pipe(to) as it doesn't forward errors. stream.options \u00b6 \u7c7b\u578b: Options The options used to make the request. stream.response \u00b6 \u7c7b\u578b: IncomingMessage The underlying IncomingMessage instance. stream.requestUrl \u00b6 \u7c7b\u578b: URL The current URL object in this try. stream.redirectUrls \u00b6 \u7c7b\u578b: URL[] An array of URLs of consecutive requests. stream.retryCount \u00b6 \u7c7b\u578b: number The current retry count. Note: Must be overriden when retrying. stream.ip \u00b6 \u7c7b\u578b: string | undefined The destination IP address. stream.isAborted \u00b6 \u7c7b\u578b: boolean Whether the request has been aborted or not. stream.socket \u00b6 \u7c7b\u578b: net.Socket | tls.Socket | undefined The socket used for this particular request. stream.downloadProgress \u00b6 \u7c7b\u578b: Progress An object representing how much data have been downloaded. stream.uploadProgress \u00b6 \u7c7b\u578b: Progress An object representing how much data have been uploaded. Note: When a chunk is greater than highWaterMark , the progress won't be emitted. The body needs to be split into chunks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import got from \"got\" ; const body = Buffer . alloc ( 1024 * 1024 ); // 1MB function * chunkify ( buffer , chunkSize = 64 * 1024 ) { for ( let pos = 0 ; pos < buffer . byteLength ; pos += chunkSize ) { yield buffer . subarray ( pos , pos + chunkSize ); } } const stream = got . stream . post ( \"https://httpbin.org/anything\" , { body : chunkify ( body ), }); stream . resume (); stream . on ( \"uploadProgress\" , ( progress ) => { console . log ( progress ); }); stream.timings \u00b6 \u7c7b\u578b: Timings An object representing performance information. To generate the timings, Got uses the http-timer package. stream.isFromCache \u00b6 \u7c7b\u578b: boolean | undefined Whether the response has been fetched from cache. stream.reusedSocket \u00b6 \u7c7b\u578b: boolean Whether the socket was used for other previous requests. Events \u00b6 stream.on('response', \u2026) \u00b6 response \u00b6 \u7c7b\u578b: PlainResponse This is emitted when a HTTP response is received. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { pipeline } from \"node:stream/promises\" ; import { createWriteStream } from \"node:fs\" ; import got from \"got\" ; const readStream = got . stream ( \"http://example.com/image.png\" , { throwHttpErrors : false }); const onError = ( error ) => { // Do something with it. }; readStream . on ( \"response\" , async ( response ) => { if ( response . headers . age > 3600 ) { console . log ( \"Failure - response too old\" ); readStream . destroy (); // Destroy the stream to prevent hanging resources. return ; } // Prevent `onError` being called twice. readStream . off ( \"error\" , onError ); try { await pipeline ( readStream , createWriteStream ( \"image.png\" )); console . log ( \"Success\" ); } catch ( error ) { onError ( error ); } }); readStream . once ( \"error\" , onError ); stream.on('downloadProgress', \u2026) \u00b6 progress \u00b6 \u7c7b\u578b: Progress This is emitted on every time stream.downloadProgress is updated. stream.on('uploadProgress', \u2026) \u00b6 progress \u00b6 \u7c7b\u578b: Progress This is emitted on every time stream.uploadProgress is updated. stream.on('retry', \u2026) \u00b6 To enable retrying when using streams, a retry handler must be attached. When this event is emitted, you should reset the stream you were writing to and prepare the body again. Note: HTTPError s cannot be retried if options.throwHttpErrors is false . This is because stream data is saved to error.response.body and streams can be read only once. For the Promise API, there is no such limitation. retryCount \u00b6 \u7c7b\u578b: number The current retry count. error \u00b6 \u7c7b\u578b: RequestError The error that caused this retry. createRetryStream \u00b6 \u7c7b\u578b: (options?: OptionsInit) => Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import fs from \"node:fs\" ; import got from \"got\" ; let writeStream ; const fn = ( retryStream ) => { const options = { headers : { foo : \"bar\" , }, }; const stream = retryStream ?? got . stream ( \"https://example.com\" , options ); if ( writeStream ) { writeStream . destroy (); } writeStream = fs . createWriteStream ( \"example-com.html\" ); stream . pipe ( writeStream ); // If you don't attach the listener, it will NOT make a retry. // It automatically checks the listener count so it knows whether to retry or not :) stream . once ( \"retry\" , ( retryCount , error , createRetryStream ) => { fn ( createRetryStream ()); // or: fn(createRetryStream(optionsToMerge)) }); }; fn (); stream.on('redirect', \u2026) \u00b6 updatedOptions \u00b6 \u7c7b\u578b: Options The new options used to make the next request. response \u00b6 \u7c7b\u578b: IncomingMessage The IncomingMessage instance the redirect came from. Internal usage \u00b6 This are the functions used internally by Got. Other non-documented functions are private and should not be accessible. stream.flush() \u00b6 This function is executed automatically by Got. It marks the current stream as ready. If an error occurs before stream.flush() is called, it's thrown immediately after stream.flush() . stream._beforeError(error) \u00b6 This function is called instead stream.destroy(error) , required in order to exectue async logic, such as reading the response (e.g. when ERR_NON_2XX_3XX_RESPONSE occurs). stream._noPipe \u00b6 \u7c7b\u578b: boolean Whether piping is disabled or not. This property is used by the Promise API. Response \u00b6 Source code: source/core/response.ts Extends: IncomingMessage requestUrl \u00b6 \u7c7b\u578b: URL The original request URL. It is the first argument when calling got(\u2026) . redirectUrls \u00b6 \u7c7b\u578b: URL[] The redirect URLs. request \u00b6 \u7c7b\u578b: Request The underlying Got stream. ip \u00b6 \u7c7b\u578b: string The server's IP address. Note: Not available when the response is cached. isFromCache \u00b6 \u7c7b\u578b: boolean Whether the response comes from cache or not. ok \u00b6 \u7c7b\u578b: boolean Whether the response was successful Note: A request is successful when the status code of the final request is 2xx or 3xx . When following redirects , a request is successful only when the status code of the final request is 2xx . 304 responses are always considered successful. Got throws automatically when response.ok is false and throwHttpErrors is true . statusCode \u00b6 \u7c7b\u578b: number The HTTP status code . url \u00b6 \u7c7b\u578b: string The final URL after all redirects. timings \u00b6 \u7c7b\u578b: Timings The same as request.timings . retryCount \u00b6 \u7c7b\u578b: number The same as request.retryCount . rawBody \u00b6 \u7c7b\u578b: Buffer Note: This property is only accessible when using Promise API. The raw response body buffer. body \u00b6 \u7c7b\u578b: unknown Note: This property is only accessible when using Promise API. The parsed response body. aborted \u00b6 \u7c7b\u578b: boolean The same as request.aborted . complete \u00b6 \u7c7b\u578b: boolean If true , the response has been fully parsed. socket \u00b6 \u7c7b\u578b: net.Socket | tls.TLSSocket The same as request.socket . headers \u00b6 \u7c7b\u578b: object<string, string> The response headers . statusMessage \u00b6 \u7c7b\u578b: string The status message corresponding to the status code.","title":"Stream API"},{"location":"3-streams/#stream-api","text":"Source code: source/core/index.ts","title":"Stream API"},{"location":"3-streams/#gotstreamurl-options-defaults","text":"","title":"got.stream(url, options, defaults)"},{"location":"3-streams/#goturl-options-isstream-true-defaults","text":"The two functions above are exposed by the got main interface and return a new instance of Request .","title":"got(url, {...options, isStream: true}, defaults)"},{"location":"3-streams/#new-requesturl-options-defaults","text":"Extends: Duplex stream This constructor takes the same arguments as the Got promise. Note: When piping to ServerResponse , the headers will be automatically copied. In order to prevent this behavior you need to override the request headers in a beforeRequest hook. Note: If the body , json or form option is used, this stream will be read-only. Note: While got.post('https://example.com') resolves, got.stream.post('https://example.com') will hang indefinitely until a body is provided. If there's no body on purpose, remember to stream.end() or set the body option to an empty string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { promisify } from \"node:util\" ; import stream from \"node:stream\" ; import fs from \"node:fs\" ; import got from \"got\" ; const pipeline = promisify ( stream . pipeline ); // This example streams the GET response of a URL to a file. await pipeline ( got . stream ( \"https://sindresorhus.com\" ), fs . createWriteStream ( \"index.html\" )); // For POST, PUT, PATCH, and DELETE methods, `got.stream` returns a `stream.Writable`. // This example POSTs the contents of a file to a URL. await pipeline ( fs . createReadStream ( \"index.html\" ), got . stream . post ( \"https://sindresorhus.com\" ), new stream . PassThrough () ); // In order to POST, PUT, PATCH, or DELETE without a request body, explicitly specify an empty body: await pipeline ( got . stream . post ( \"https://sindresorhus.com\" , { body : \"\" }), new stream . PassThrough ()); Please note that new stream.PassThrough() is required in order to catch read errors. If it was missing then pipeline wouldn't catch any read errors because there would be no stream to pipe to. In other words, it would only check errors when writing. Tip: Avoid from.pipe(to) as it doesn't forward errors.","title":"new Request(url, options, defaults)"},{"location":"3-streams/#streamoptions","text":"\u7c7b\u578b: Options The options used to make the request.","title":"stream.options"},{"location":"3-streams/#streamresponse","text":"\u7c7b\u578b: IncomingMessage The underlying IncomingMessage instance.","title":"stream.response"},{"location":"3-streams/#streamrequesturl","text":"\u7c7b\u578b: URL The current URL object in this try.","title":"stream.requestUrl"},{"location":"3-streams/#streamredirecturls","text":"\u7c7b\u578b: URL[] An array of URLs of consecutive requests.","title":"stream.redirectUrls"},{"location":"3-streams/#streamretrycount","text":"\u7c7b\u578b: number The current retry count. Note: Must be overriden when retrying.","title":"stream.retryCount"},{"location":"3-streams/#streamip","text":"\u7c7b\u578b: string | undefined The destination IP address.","title":"stream.ip"},{"location":"3-streams/#streamisaborted","text":"\u7c7b\u578b: boolean Whether the request has been aborted or not.","title":"stream.isAborted"},{"location":"3-streams/#streamsocket","text":"\u7c7b\u578b: net.Socket | tls.Socket | undefined The socket used for this particular request.","title":"stream.socket"},{"location":"3-streams/#streamdownloadprogress","text":"\u7c7b\u578b: Progress An object representing how much data have been downloaded.","title":"stream.downloadProgress"},{"location":"3-streams/#streamuploadprogress","text":"\u7c7b\u578b: Progress An object representing how much data have been uploaded. Note: When a chunk is greater than highWaterMark , the progress won't be emitted. The body needs to be split into chunks. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import got from \"got\" ; const body = Buffer . alloc ( 1024 * 1024 ); // 1MB function * chunkify ( buffer , chunkSize = 64 * 1024 ) { for ( let pos = 0 ; pos < buffer . byteLength ; pos += chunkSize ) { yield buffer . subarray ( pos , pos + chunkSize ); } } const stream = got . stream . post ( \"https://httpbin.org/anything\" , { body : chunkify ( body ), }); stream . resume (); stream . on ( \"uploadProgress\" , ( progress ) => { console . log ( progress ); });","title":"stream.uploadProgress"},{"location":"3-streams/#streamtimings","text":"\u7c7b\u578b: Timings An object representing performance information. To generate the timings, Got uses the http-timer package.","title":"stream.timings"},{"location":"3-streams/#streamisfromcache","text":"\u7c7b\u578b: boolean | undefined Whether the response has been fetched from cache.","title":"stream.isFromCache"},{"location":"3-streams/#streamreusedsocket","text":"\u7c7b\u578b: boolean Whether the socket was used for other previous requests.","title":"stream.reusedSocket"},{"location":"3-streams/#events","text":"","title":"Events"},{"location":"3-streams/#streamonresponse","text":"","title":"stream.on('response', \u2026)"},{"location":"3-streams/#response","text":"\u7c7b\u578b: PlainResponse This is emitted when a HTTP response is received. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import { pipeline } from \"node:stream/promises\" ; import { createWriteStream } from \"node:fs\" ; import got from \"got\" ; const readStream = got . stream ( \"http://example.com/image.png\" , { throwHttpErrors : false }); const onError = ( error ) => { // Do something with it. }; readStream . on ( \"response\" , async ( response ) => { if ( response . headers . age > 3600 ) { console . log ( \"Failure - response too old\" ); readStream . destroy (); // Destroy the stream to prevent hanging resources. return ; } // Prevent `onError` being called twice. readStream . off ( \"error\" , onError ); try { await pipeline ( readStream , createWriteStream ( \"image.png\" )); console . log ( \"Success\" ); } catch ( error ) { onError ( error ); } }); readStream . once ( \"error\" , onError );","title":"response"},{"location":"3-streams/#streamondownloadprogress","text":"","title":"stream.on('downloadProgress', \u2026)"},{"location":"3-streams/#progress","text":"\u7c7b\u578b: Progress This is emitted on every time stream.downloadProgress is updated.","title":"progress"},{"location":"3-streams/#streamonuploadprogress","text":"","title":"stream.on('uploadProgress', \u2026)"},{"location":"3-streams/#progress_1","text":"\u7c7b\u578b: Progress This is emitted on every time stream.uploadProgress is updated.","title":"progress"},{"location":"3-streams/#streamonretry","text":"To enable retrying when using streams, a retry handler must be attached. When this event is emitted, you should reset the stream you were writing to and prepare the body again. Note: HTTPError s cannot be retried if options.throwHttpErrors is false . This is because stream data is saved to error.response.body and streams can be read only once. For the Promise API, there is no such limitation.","title":"stream.on('retry', \u2026)"},{"location":"3-streams/#retrycount","text":"\u7c7b\u578b: number The current retry count.","title":"retryCount"},{"location":"3-streams/#error","text":"\u7c7b\u578b: RequestError The error that caused this retry.","title":"error"},{"location":"3-streams/#createretrystream","text":"\u7c7b\u578b: (options?: OptionsInit) => Request 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import fs from \"node:fs\" ; import got from \"got\" ; let writeStream ; const fn = ( retryStream ) => { const options = { headers : { foo : \"bar\" , }, }; const stream = retryStream ?? got . stream ( \"https://example.com\" , options ); if ( writeStream ) { writeStream . destroy (); } writeStream = fs . createWriteStream ( \"example-com.html\" ); stream . pipe ( writeStream ); // If you don't attach the listener, it will NOT make a retry. // It automatically checks the listener count so it knows whether to retry or not :) stream . once ( \"retry\" , ( retryCount , error , createRetryStream ) => { fn ( createRetryStream ()); // or: fn(createRetryStream(optionsToMerge)) }); }; fn ();","title":"createRetryStream"},{"location":"3-streams/#streamonredirect","text":"","title":"stream.on('redirect', \u2026)"},{"location":"3-streams/#updatedoptions","text":"\u7c7b\u578b: Options The new options used to make the next request.","title":"updatedOptions"},{"location":"3-streams/#response_1","text":"\u7c7b\u578b: IncomingMessage The IncomingMessage instance the redirect came from.","title":"response"},{"location":"3-streams/#internal-usage","text":"This are the functions used internally by Got. Other non-documented functions are private and should not be accessible.","title":"Internal usage"},{"location":"3-streams/#streamflush","text":"This function is executed automatically by Got. It marks the current stream as ready. If an error occurs before stream.flush() is called, it's thrown immediately after stream.flush() .","title":"stream.flush()"},{"location":"3-streams/#stream_beforeerrorerror","text":"This function is called instead stream.destroy(error) , required in order to exectue async logic, such as reading the response (e.g. when ERR_NON_2XX_3XX_RESPONSE occurs).","title":"stream._beforeError(error)"},{"location":"3-streams/#stream_nopipe","text":"\u7c7b\u578b: boolean Whether piping is disabled or not. This property is used by the Promise API.","title":"stream._noPipe"},{"location":"3-streams/#response_2","text":"Source code: source/core/response.ts Extends: IncomingMessage","title":"Response"},{"location":"3-streams/#requesturl","text":"\u7c7b\u578b: URL The original request URL. It is the first argument when calling got(\u2026) .","title":"requestUrl"},{"location":"3-streams/#redirecturls","text":"\u7c7b\u578b: URL[] The redirect URLs.","title":"redirectUrls"},{"location":"3-streams/#request","text":"\u7c7b\u578b: Request The underlying Got stream.","title":"request"},{"location":"3-streams/#ip","text":"\u7c7b\u578b: string The server's IP address. Note: Not available when the response is cached.","title":"ip"},{"location":"3-streams/#isfromcache","text":"\u7c7b\u578b: boolean Whether the response comes from cache or not.","title":"isFromCache"},{"location":"3-streams/#ok","text":"\u7c7b\u578b: boolean Whether the response was successful Note: A request is successful when the status code of the final request is 2xx or 3xx . When following redirects , a request is successful only when the status code of the final request is 2xx . 304 responses are always considered successful. Got throws automatically when response.ok is false and throwHttpErrors is true .","title":"ok"},{"location":"3-streams/#statuscode","text":"\u7c7b\u578b: number The HTTP status code .","title":"statusCode"},{"location":"3-streams/#url","text":"\u7c7b\u578b: string The final URL after all redirects.","title":"url"},{"location":"3-streams/#timings","text":"\u7c7b\u578b: Timings The same as request.timings .","title":"timings"},{"location":"3-streams/#retrycount_1","text":"\u7c7b\u578b: number The same as request.retryCount .","title":"retryCount"},{"location":"3-streams/#rawbody","text":"\u7c7b\u578b: Buffer Note: This property is only accessible when using Promise API. The raw response body buffer.","title":"rawBody"},{"location":"3-streams/#body","text":"\u7c7b\u578b: unknown Note: This property is only accessible when using Promise API. The parsed response body.","title":"body"},{"location":"3-streams/#aborted","text":"\u7c7b\u578b: boolean The same as request.aborted .","title":"aborted"},{"location":"3-streams/#complete","text":"\u7c7b\u578b: boolean If true , the response has been fully parsed.","title":"complete"},{"location":"3-streams/#socket","text":"\u7c7b\u578b: net.Socket | tls.TLSSocket The same as request.socket .","title":"socket"},{"location":"3-streams/#headers","text":"\u7c7b\u578b: object<string, string> The response headers .","title":"headers"},{"location":"3-streams/#statusmessage","text":"\u7c7b\u578b: string The status message corresponding to the status code.","title":"statusMessage"},{"location":"4-pagination/","text":"Pagination API \u00b6 Source code: source/create.ts How does the Link header work? \u00b6 The RFC5988 defines how the Link header looks like. When the response has been processed, Got looks for the reference of the next relation . This way Got knows the URL it should visit afterwards. The header can look like this: 1 Link: <https://api.github.com/repositories/18193978/commits?page=2>; rel=\"next\", <https://api.github.com/repositories/18193978/commits?page=44>; rel=\"last\" By default, Got looks only at the next relation. To use other relations , you need to customize the paginate function below. got.paginate(url, options?) \u00b6 got.paginate.each(url, options?) \u00b6 Returns an async iterator . This is memory efficient, as the logic is executed immediately when new data comes in. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const countLimit = 10 ; const pagination = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); } got.paginate.all(url, options?) \u00b6 Note: Querying a large dataset significantly increases memory usage. Returns a Promise for an array of all results. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const countLimit = 10 ; const results = await got . paginate . all ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); console . log ( results ); pagination \u00b6 \u7c7b\u578b: object Default: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { transform : ( response : Response ) => { if ( response . request . options . responseType === 'json' ) { return response . body ; } return JSON . parse ( response . body as string ); }, paginate : ({ response }) => { const rawLinkHeader = response . headers . link ; if ( typeof rawLinkHeader !== 'string' || rawLinkHeader . trim () === '' ) { return false ; } const parsed = parseLinkHeader ( rawLinkHeader ); const next = parsed . find ( entry => entry . parameters . rel === 'next' || entry . parameters . rel === '\"next\"' ); if ( next ) { return { url : new URL ( next . reference , response . requestUrl ) }; } return false ; }, filter : () => true , shouldContinue : () => true , countLimit : Number . POSITIVE_INFINITY , backoff : 0 , requestLimit : 10 _000 , stackAllItems : false } This option represents the pagination object. transform \u00b6 \u7c7b\u578b: Function \u9ed8\u8ba4: response => JSON.parse(response.body) A function that transforms Response into an array of items. This is where you should do the parsing. paginate \u00b6 \u7c7b\u578b: Function \u9ed8\u8ba4: Link header logic The function takes an object with the following properties: response - The current response object, currentItems - Items from the current response, allItems - An empty array, unless stackAllItems is true , otherwise it contains all emitted items. It should return an object representing Got options pointing to the next page. If there is no next page, false should be returned instead. The options are merged automatically with the previous request. Therefore the options returned by pagination.paginate(\u2026) must reflect changes only. Note: The url option (if set) accepts only a URL instance. This prevents prefixUrl ambiguity. In order to use a relative URL string, merge it via new URL(relativeUrl, response.url) . filter \u00b6 \u7c7b\u578b: Function \u9ed8\u8ba4: ({item, currentItems, allItems}) => true Whether the item should be emitted or not. shouldContinue \u00b6 \u7c7b\u578b: Function \u9ed8\u8ba4: ({item, currentItems, allItems}) => true Note: This function executes only when filter returns true . For example, if you need to stop before emitting an entry with some flag, you should use ({item}) => !item.flag . If you want to stop after emitting the entry, you should use ({item, allItems}) => allItems.some(item => item.flag) instead. countLimit \u00b6 \u7c7b\u578b: number \u9ed8\u8ba4: Number.POSITIVE_INFINITY The maximum amount of items that should be emitted. backoff \u00b6 \u7c7b\u578b: number \u9ed8\u8ba4: 0 Milliseconds to wait before the next request is triggered. requestLimit \u00b6 \u7c7b\u578b: number \u9ed8\u8ba4: 10000 The maximum amount of request that should be triggered. Note: Retries on failure are not counted towards this limit. stackAllItems \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: false Defines how allItems is managed in pagination.paginate , pagination.filter and pagination.shouldContinue . By default, allItems is always an empty array. Setting this to true will significantly increase memory usage when working with a large dataset. Example \u00b6 In this example we will use searchParams instead of Link header. Just to show how you can customize the paginate function. The reason filter looks exactly the same like shouldContinue is that the latter will tell Got to stop once we reach our timestamp. The filter function is needed as well, because in the same response we can get results with different timestamps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import got from \"got\" ; import Bourne from \"@hapi/bourne\" ; const max = Date . now () - 1000 * 86400 * 7 ; const iterator = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { paginate : ({ response , currentItems }) => { // If there are no more data, finish. if ( currentItems . length === 0 ) { return false ; } // Get the current page number. const { searchParams } = response . request . options ; const previousPage = Number ( searchParams . get ( \"page\" ) ?? 1 ); // Update the page number by one. return { searchParams : { page : previousPage + 1 , }, }; }, // Using `Bourne` to prevent prototype pollution. transform : ( response ) => Bourne . parse ( response . body ), filter : ({ item }) => { // Check if the commit time exceeds our range. const date = new Date ( item . commit . committer . date ); const end = date . getTime () - max >= 0 ; return end ; }, shouldContinue : ({ item }) => { // Check if the commit time exceeds our range. const date = new Date ( item . commit . committer . date ); const end = date . getTime () - max >= 0 ; return end ; }, // We want only 50 results. countLimit : 50 , // Wait 1s before making another request to prevent API rate limiting. backoff : 1000 , // It is a good practice to set an upper limit of how many requests can be made. // This way we can avoid infinite loops. requestLimit : 10 , // In this case, we don't need to store all the items we receive. // They are processed immediately. stackAllItems : false , }, }); console . log ( \"Last 50 commits from now to week ago:\" ); for await ( const item of iterator ) { console . log ( item . commit . message . split ( \"\\n\" )[ 0 ]); }","title":"Pagination API"},{"location":"4-pagination/#pagination-api","text":"Source code: source/create.ts","title":"Pagination API"},{"location":"4-pagination/#how-does-the-link-header-work","text":"The RFC5988 defines how the Link header looks like. When the response has been processed, Got looks for the reference of the next relation . This way Got knows the URL it should visit afterwards. The header can look like this: 1 Link: <https://api.github.com/repositories/18193978/commits?page=2>; rel=\"next\", <https://api.github.com/repositories/18193978/commits?page=44>; rel=\"last\" By default, Got looks only at the next relation. To use other relations , you need to customize the paginate function below.","title":"How does the Link header work?"},{"location":"4-pagination/#gotpaginateurl-options","text":"","title":"got.paginate(url, options?)"},{"location":"4-pagination/#gotpaginateeachurl-options","text":"Returns an async iterator . This is memory efficient, as the logic is executed immediately when new data comes in. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const countLimit = 10 ; const pagination = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); }","title":"got.paginate.each(url, options?)"},{"location":"4-pagination/#gotpaginateallurl-options","text":"Note: Querying a large dataset significantly increases memory usage. Returns a Promise for an array of all results. 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const countLimit = 10 ; const results = await got . paginate . all ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); console . log ( results );","title":"got.paginate.all(url, options?)"},{"location":"4-pagination/#pagination","text":"\u7c7b\u578b: object Default: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { transform : ( response : Response ) => { if ( response . request . options . responseType === 'json' ) { return response . body ; } return JSON . parse ( response . body as string ); }, paginate : ({ response }) => { const rawLinkHeader = response . headers . link ; if ( typeof rawLinkHeader !== 'string' || rawLinkHeader . trim () === '' ) { return false ; } const parsed = parseLinkHeader ( rawLinkHeader ); const next = parsed . find ( entry => entry . parameters . rel === 'next' || entry . parameters . rel === '\"next\"' ); if ( next ) { return { url : new URL ( next . reference , response . requestUrl ) }; } return false ; }, filter : () => true , shouldContinue : () => true , countLimit : Number . POSITIVE_INFINITY , backoff : 0 , requestLimit : 10 _000 , stackAllItems : false } This option represents the pagination object.","title":"pagination"},{"location":"4-pagination/#transform","text":"\u7c7b\u578b: Function \u9ed8\u8ba4: response => JSON.parse(response.body) A function that transforms Response into an array of items. This is where you should do the parsing.","title":"transform"},{"location":"4-pagination/#paginate","text":"\u7c7b\u578b: Function \u9ed8\u8ba4: Link header logic The function takes an object with the following properties: response - The current response object, currentItems - Items from the current response, allItems - An empty array, unless stackAllItems is true , otherwise it contains all emitted items. It should return an object representing Got options pointing to the next page. If there is no next page, false should be returned instead. The options are merged automatically with the previous request. Therefore the options returned by pagination.paginate(\u2026) must reflect changes only. Note: The url option (if set) accepts only a URL instance. This prevents prefixUrl ambiguity. In order to use a relative URL string, merge it via new URL(relativeUrl, response.url) .","title":"paginate"},{"location":"4-pagination/#filter","text":"\u7c7b\u578b: Function \u9ed8\u8ba4: ({item, currentItems, allItems}) => true Whether the item should be emitted or not.","title":"filter"},{"location":"4-pagination/#shouldcontinue","text":"\u7c7b\u578b: Function \u9ed8\u8ba4: ({item, currentItems, allItems}) => true Note: This function executes only when filter returns true . For example, if you need to stop before emitting an entry with some flag, you should use ({item}) => !item.flag . If you want to stop after emitting the entry, you should use ({item, allItems}) => allItems.some(item => item.flag) instead.","title":"shouldContinue"},{"location":"4-pagination/#countlimit","text":"\u7c7b\u578b: number \u9ed8\u8ba4: Number.POSITIVE_INFINITY The maximum amount of items that should be emitted.","title":"countLimit"},{"location":"4-pagination/#backoff","text":"\u7c7b\u578b: number \u9ed8\u8ba4: 0 Milliseconds to wait before the next request is triggered.","title":"backoff"},{"location":"4-pagination/#requestlimit","text":"\u7c7b\u578b: number \u9ed8\u8ba4: 10000 The maximum amount of request that should be triggered. Note: Retries on failure are not counted towards this limit.","title":"requestLimit"},{"location":"4-pagination/#stackallitems","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: false Defines how allItems is managed in pagination.paginate , pagination.filter and pagination.shouldContinue . By default, allItems is always an empty array. Setting this to true will significantly increase memory usage when working with a large dataset.","title":"stackAllItems"},{"location":"4-pagination/#example","text":"In this example we will use searchParams instead of Link header. Just to show how you can customize the paginate function. The reason filter looks exactly the same like shouldContinue is that the latter will tell Got to stop once we reach our timestamp. The filter function is needed as well, because in the same response we can get results with different timestamps. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import got from \"got\" ; import Bourne from \"@hapi/bourne\" ; const max = Date . now () - 1000 * 86400 * 7 ; const iterator = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { paginate : ({ response , currentItems }) => { // If there are no more data, finish. if ( currentItems . length === 0 ) { return false ; } // Get the current page number. const { searchParams } = response . request . options ; const previousPage = Number ( searchParams . get ( \"page\" ) ?? 1 ); // Update the page number by one. return { searchParams : { page : previousPage + 1 , }, }; }, // Using `Bourne` to prevent prototype pollution. transform : ( response ) => Bourne . parse ( response . body ), filter : ({ item }) => { // Check if the commit time exceeds our range. const date = new Date ( item . commit . committer . date ); const end = date . getTime () - max >= 0 ; return end ; }, shouldContinue : ({ item }) => { // Check if the commit time exceeds our range. const date = new Date ( item . commit . committer . date ); const end = date . getTime () - max >= 0 ; return end ; }, // We want only 50 results. countLimit : 50 , // Wait 1s before making another request to prevent API rate limiting. backoff : 1000 , // It is a good practice to set an upper limit of how many requests can be made. // This way we can avoid infinite loops. requestLimit : 10 , // In this case, we don't need to store all the items we receive. // They are processed immediately. stackAllItems : false , }, }); console . log ( \"Last 50 commits from now to week ago:\" ); for await ( const item of iterator ) { console . log ( item . commit . message . split ( \"\\n\" )[ 0 ]); }","title":"Example"},{"location":"5-https/","text":"Advanced HTTPS API \u00b6 https \u00b6 \u7c7b\u578b: object This option represents the options used to make HTTPS requests. alpnProtocols \u00b6 \u7c7b\u578b: string[] \u9ed8\u8ba4: ['http/1.1'] Acceptable ALPN protocols. If the http2 option is true , this defaults to ['h2', 'http/1.1'] . rejectUnauthorized \u00b6 \u7c7b\u578b: boolean \u9ed8\u8ba4: true If true , it will throw on invalid certificates, such as expired or self-signed ones. checkServerIdentity \u00b6 \u7c7b\u578b: (hostname: string, certificate: DetailedPeerCertificate) => Error | undefined \u9ed8\u8ba4: tls.checkServerIdentity Custom check of the certificate. Useful for pinning certificates. The function must return undefined if the check succeeded. If it failed, an Error should be returned. Note: In order to have the function called, the certificate must not be expired, self-signed nor with an untrusted-root. Check Node.js docs for an example. certificateAuthority \u00b6 \u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the ca TLS option for better readability. Overrides trusted CA certificates. Defaults to CAs provided by Mozilla . 1 2 3 4 5 6 7 8 import got from \"got\" ; // Single Certificate Authority await got ( \"https://example.com\" , { https : { certificateAuthority : fs . readFileSync ( \"./my_ca.pem\" ), }, }); key \u00b6 \u7c7b\u578b: string | Buffer | string[] | Buffer[] | object[] Private keys in PEM format . Multiple keys with different passphrases can be provided as an array of {pem: <string | Buffer>, passphrase: <string>} . Note: Encrypted keys will be decrypted with https.passphrase . passphrase \u00b6 \u7c7b\u578b: string Shared passphrase used for a single private key and/or a PFX. certificate \u00b6 \u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the cert TLS option for better readability. Certificate chains in PEM format . One certificate chain should be provided per private key. When providing multiple certificate chains, they do not have to be in the same order as their private keys in https.key . pfx \u00b6 \u7c7b\u578b: string | Buffer | string[] | Buffer[] | object[] PFX or PKCS12 encoded private key and certificate chain. Using https.pfx is an alternative to providing https.key and https.certificate individually. A PFX is usually encrypted, then https.passphrase will be used to decrypt it. Multiple PFX can be be provided as an array of unencrypted buffers or an array of objects like: 1 2 3 4 { buffer : string | Buffer , passphrase? : string } certificateRevocationLists \u00b6 \u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the crl TLS option for better readability. Other HTTPS options \u00b6 Documentation for the below options. ciphers dhparam signatureAlgorithms (renamed from sigalgs ) minVersion maxVersion honorCipherOrder tlsSessionLifetime (renamed from sessionTimeout ) ecdhCurve Examples \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import got from \"got\" ; // Single key with certificate await got ( \"https://example.com\" , { https : { key : fs . readFileSync ( \"./client_key.pem\" ), certificate : fs . readFileSync ( \"./client_cert.pem\" ), }, }); // Multiple keys with certificates (out of order) await got ( \"https://example.com\" , { https : { key : [ fs . readFileSync ( \"./client_key1.pem\" ), fs . readFileSync ( \"./client_key2.pem\" )], certificate : [ fs . readFileSync ( \"./client_cert2.pem\" ), fs . readFileSync ( \"./client_cert1.pem\" )], }, }); // Single key with passphrase await got ( \"https://example.com\" , { https : { key : fs . readFileSync ( \"./client_key.pem\" ), certificate : fs . readFileSync ( \"./client_cert.pem\" ), passphrase : \"client_key_passphrase\" , }, }); // Multiple keys with different passphrases await got ( \"https://example.com\" , { https : { key : [ { pem : fs . readFileSync ( \"./client_key1.pem\" ), passphrase : \"passphrase1\" }, { pem : fs . readFileSync ( \"./client_key2.pem\" ), passphrase : \"passphrase2\" }, ], certificate : [ fs . readFileSync ( \"./client_cert1.pem\" ), fs . readFileSync ( \"./client_cert2.pem\" )], }, }); // Single encrypted PFX with passphrase await got ( \"https://example.com\" , { https : { pfx : fs . readFileSync ( \"./fake.pfx\" ), passphrase : \"passphrase\" , }, }); // Multiple encrypted PFX's with different passphrases await got ( \"https://example.com\" , { https : { pfx : [ { buffer : fs . readFileSync ( \"./key1.pfx\" ), passphrase : \"passphrase1\" , }, { buffer : fs . readFileSync ( \"./key2.pfx\" ), passphrase : \"passphrase2\" , }, ], }, }); // Multiple encrypted PFX's with single passphrase await got ( \"https://example.com\" , { https : { passphrase : \"passphrase\" , pfx : [ { buffer : fs . readFileSync ( \"./key1.pfx\" ), }, { buffer : fs . readFileSync ( \"./key2.pfx\" ), }, ], }, });","title":"Advanced HTTPS API"},{"location":"5-https/#advanced-https-api","text":"","title":"Advanced HTTPS API"},{"location":"5-https/#https","text":"\u7c7b\u578b: object This option represents the options used to make HTTPS requests.","title":"https"},{"location":"5-https/#alpnprotocols","text":"\u7c7b\u578b: string[] \u9ed8\u8ba4: ['http/1.1'] Acceptable ALPN protocols. If the http2 option is true , this defaults to ['h2', 'http/1.1'] .","title":"alpnProtocols"},{"location":"5-https/#rejectunauthorized","text":"\u7c7b\u578b: boolean \u9ed8\u8ba4: true If true , it will throw on invalid certificates, such as expired or self-signed ones.","title":"rejectUnauthorized"},{"location":"5-https/#checkserveridentity","text":"\u7c7b\u578b: (hostname: string, certificate: DetailedPeerCertificate) => Error | undefined \u9ed8\u8ba4: tls.checkServerIdentity Custom check of the certificate. Useful for pinning certificates. The function must return undefined if the check succeeded. If it failed, an Error should be returned. Note: In order to have the function called, the certificate must not be expired, self-signed nor with an untrusted-root. Check Node.js docs for an example.","title":"checkServerIdentity"},{"location":"5-https/#certificateauthority","text":"\u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the ca TLS option for better readability. Overrides trusted CA certificates. Defaults to CAs provided by Mozilla . 1 2 3 4 5 6 7 8 import got from \"got\" ; // Single Certificate Authority await got ( \"https://example.com\" , { https : { certificateAuthority : fs . readFileSync ( \"./my_ca.pem\" ), }, });","title":"certificateAuthority"},{"location":"5-https/#key","text":"\u7c7b\u578b: string | Buffer | string[] | Buffer[] | object[] Private keys in PEM format . Multiple keys with different passphrases can be provided as an array of {pem: <string | Buffer>, passphrase: <string>} . Note: Encrypted keys will be decrypted with https.passphrase .","title":"key"},{"location":"5-https/#passphrase","text":"\u7c7b\u578b: string Shared passphrase used for a single private key and/or a PFX.","title":"passphrase"},{"location":"5-https/#certificate","text":"\u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the cert TLS option for better readability. Certificate chains in PEM format . One certificate chain should be provided per private key. When providing multiple certificate chains, they do not have to be in the same order as their private keys in https.key .","title":"certificate"},{"location":"5-https/#pfx","text":"\u7c7b\u578b: string | Buffer | string[] | Buffer[] | object[] PFX or PKCS12 encoded private key and certificate chain. Using https.pfx is an alternative to providing https.key and https.certificate individually. A PFX is usually encrypted, then https.passphrase will be used to decrypt it. Multiple PFX can be be provided as an array of unencrypted buffers or an array of objects like: 1 2 3 4 { buffer : string | Buffer , passphrase? : string }","title":"pfx"},{"location":"5-https/#certificaterevocationlists","text":"\u7c7b\u578b: string | Buffer | string[] | Buffer[] Note: The option has been renamed from the crl TLS option for better readability.","title":"certificateRevocationLists"},{"location":"5-https/#other-https-options","text":"Documentation for the below options. ciphers dhparam signatureAlgorithms (renamed from sigalgs ) minVersion maxVersion honorCipherOrder tlsSessionLifetime (renamed from sessionTimeout ) ecdhCurve","title":"Other HTTPS options"},{"location":"5-https/#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import got from \"got\" ; // Single key with certificate await got ( \"https://example.com\" , { https : { key : fs . readFileSync ( \"./client_key.pem\" ), certificate : fs . readFileSync ( \"./client_cert.pem\" ), }, }); // Multiple keys with certificates (out of order) await got ( \"https://example.com\" , { https : { key : [ fs . readFileSync ( \"./client_key1.pem\" ), fs . readFileSync ( \"./client_key2.pem\" )], certificate : [ fs . readFileSync ( \"./client_cert2.pem\" ), fs . readFileSync ( \"./client_cert1.pem\" )], }, }); // Single key with passphrase await got ( \"https://example.com\" , { https : { key : fs . readFileSync ( \"./client_key.pem\" ), certificate : fs . readFileSync ( \"./client_cert.pem\" ), passphrase : \"client_key_passphrase\" , }, }); // Multiple keys with different passphrases await got ( \"https://example.com\" , { https : { key : [ { pem : fs . readFileSync ( \"./client_key1.pem\" ), passphrase : \"passphrase1\" }, { pem : fs . readFileSync ( \"./client_key2.pem\" ), passphrase : \"passphrase2\" }, ], certificate : [ fs . readFileSync ( \"./client_cert1.pem\" ), fs . readFileSync ( \"./client_cert2.pem\" )], }, }); // Single encrypted PFX with passphrase await got ( \"https://example.com\" , { https : { pfx : fs . readFileSync ( \"./fake.pfx\" ), passphrase : \"passphrase\" , }, }); // Multiple encrypted PFX's with different passphrases await got ( \"https://example.com\" , { https : { pfx : [ { buffer : fs . readFileSync ( \"./key1.pfx\" ), passphrase : \"passphrase1\" , }, { buffer : fs . readFileSync ( \"./key2.pfx\" ), passphrase : \"passphrase2\" , }, ], }, }); // Multiple encrypted PFX's with single passphrase await got ( \"https://example.com\" , { https : { passphrase : \"passphrase\" , pfx : [ { buffer : fs . readFileSync ( \"./key1.pfx\" ), }, { buffer : fs . readFileSync ( \"./key2.pfx\" ), }, ], }, });","title":"Examples"},{"location":"6-timeout/","text":"Timeout options \u00b6 Source code: source/core/timed-out.ts It is a good practice to set a timeout to prevent hanging requests. By default, there is no timeout set. All numbers refer to milliseconds. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import got from \"got\" ; const { timings } = await got ( \"https://example.com\" , { timeout : { lookup : 100 , connect : 50 , secureConnect : 50 , socket : 1000 , send : 10000 , response : 1000 , }, }); // Alternatively: const { timings } = await got ( \"https://example.com\" , { timeout : { request : 10000 , }, }); console . log ( timings ); // { // start: 1625474926602, // socket: 1625474926605, // lookup: 1625474926610, // connect: 1625474926617, // secureConnect: 1625474926631, // upload: 1625474926631, // response: 1625474926638, // end: 1625474926642, // error: undefined, // abort: undefined, // phases: { // wait: 3, // dns: 5, // tcp: 7, // tls: 14, // request: 0, // firstByte: 7, // download: 4, // total: 40 // } // } timeout \u00b6 \u7c7b\u578b: object This object describes the maximum allowed time for particular events. lookup \u00b6 \u7c7b\u578b: number Starts when a socket is assigned. Ends when the hostname has been resolved. Does not apply when using a Unix domain socket. Does not apply when passing an IP address. It is preferred to not use any greater value than 100 . connect \u00b6 \u7c7b\u578b: number Starts when lookup completes. Ends when the socket is fully connected. If lookup does not apply to the request, this event starts when the socket is assigned and ends when the socket is connected. secureConnect \u00b6 \u7c7b\u578b: number Starts when connect completes. Ends when the handshake process completes. This timeout applies only to HTTPS requests. socket \u00b6 \u7c7b\u578b: number Starts when the socket is connected. Resets when new data is transferred. It is the same as request.setTimeout(timeout) which calls socket.setTimeout(timeout) after a socket is assigned to this request and is connected. send \u00b6 \u7c7b\u578b: number Starts when the socket is connected. Ends when all data have been written to the socket. Note: This does not assure the data have been received by the other end! It only assures that the data have been passed to the underlying OS. response \u00b6 \u7c7b\u578b: number Starts when request has been flushed. Ends when the headers are received. read \u00b6 \u7c7b\u578b: number Starts when the headers are received. Ends when the response's end event fires. Note: This timeout is blocked by https://github.com/nodejs/node/issues/35923 request \u00b6 \u7c7b\u578b: number Starts when the request is initiated. Ends when the response's end event fires. In other words, this is the global timeout.","title":"Timeout options"},{"location":"6-timeout/#timeout-options","text":"Source code: source/core/timed-out.ts It is a good practice to set a timeout to prevent hanging requests. By default, there is no timeout set. All numbers refer to milliseconds. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import got from \"got\" ; const { timings } = await got ( \"https://example.com\" , { timeout : { lookup : 100 , connect : 50 , secureConnect : 50 , socket : 1000 , send : 10000 , response : 1000 , }, }); // Alternatively: const { timings } = await got ( \"https://example.com\" , { timeout : { request : 10000 , }, }); console . log ( timings ); // { // start: 1625474926602, // socket: 1625474926605, // lookup: 1625474926610, // connect: 1625474926617, // secureConnect: 1625474926631, // upload: 1625474926631, // response: 1625474926638, // end: 1625474926642, // error: undefined, // abort: undefined, // phases: { // wait: 3, // dns: 5, // tcp: 7, // tls: 14, // request: 0, // firstByte: 7, // download: 4, // total: 40 // } // }","title":"Timeout options"},{"location":"6-timeout/#timeout","text":"\u7c7b\u578b: object This object describes the maximum allowed time for particular events.","title":"timeout"},{"location":"6-timeout/#lookup","text":"\u7c7b\u578b: number Starts when a socket is assigned. Ends when the hostname has been resolved. Does not apply when using a Unix domain socket. Does not apply when passing an IP address. It is preferred to not use any greater value than 100 .","title":"lookup"},{"location":"6-timeout/#connect","text":"\u7c7b\u578b: number Starts when lookup completes. Ends when the socket is fully connected. If lookup does not apply to the request, this event starts when the socket is assigned and ends when the socket is connected.","title":"connect"},{"location":"6-timeout/#secureconnect","text":"\u7c7b\u578b: number Starts when connect completes. Ends when the handshake process completes. This timeout applies only to HTTPS requests.","title":"secureConnect"},{"location":"6-timeout/#socket","text":"\u7c7b\u578b: number Starts when the socket is connected. Resets when new data is transferred. It is the same as request.setTimeout(timeout) which calls socket.setTimeout(timeout) after a socket is assigned to this request and is connected.","title":"socket"},{"location":"6-timeout/#send","text":"\u7c7b\u578b: number Starts when the socket is connected. Ends when all data have been written to the socket. Note: This does not assure the data have been received by the other end! It only assures that the data have been passed to the underlying OS.","title":"send"},{"location":"6-timeout/#response","text":"\u7c7b\u578b: number Starts when request has been flushed. Ends when the headers are received.","title":"response"},{"location":"6-timeout/#read","text":"\u7c7b\u578b: number Starts when the headers are received. Ends when the response's end event fires. Note: This timeout is blocked by https://github.com/nodejs/node/issues/35923","title":"read"},{"location":"6-timeout/#request","text":"\u7c7b\u578b: number Starts when the request is initiated. Ends when the response's end event fires. In other words, this is the global timeout.","title":"request"},{"location":"7-retry/","text":"Retry API \u00b6 Note: If you're looking for retry implementation using streams, check out the Retry Stream API . Tip: You can trigger a retry by throwing the RetryError in any hook. Tip: The afterResponse hook exposes a dedicated function to retry with merged options. Read more . retry \u00b6 \u7c7b\u578b: object Default: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 { limit : 2 , methods : [ 'GET' , 'PUT' , 'HEAD' , 'DELETE' , 'OPTIONS' , 'TRACE' ], statusCodes : [ 408 , 413 , 429 , 500 , 502 , 503 , 504 , 521 , 522 , 524 ], errorCodes : [ 'ETIMEDOUT' , 'ECONNRESET' , 'EADDRINUSE' , 'ECONNREFUSED' , 'EPIPE' , 'ENOTFOUND' , 'ENETUNREACH' , 'EAI_AGAIN' ], maxRetryAfter : undefined , calculateDelay : ({ computedValue }) => computedValue , backoffLimit : Number . POSITIVE_INFINITY , noise : 100 } This option represents the retry object. limit \u00b6 \u7c7b\u578b: number The maximum retry count. methods \u00b6 \u7c7b\u578b: string[] The allowed methods to retry on. Note: By default, Got does not retry on POST . statusCodes \u00b6 \u7c7b\u578b: number[] Note: Only unsuccessful requests are retried. In order to retry successful requests, use an afterResponse hook. The allowed HTTP status codes to retry on. errorCodes \u00b6 \u7c7b\u578b: string[] The allowed error codes to retry on. ETIMEDOUT - One of the timeout limits was reached. ECONNRESET - The connection was forcibly closed. EADDRINUSE - Could not bind to any free port. ECONNREFUSED - The connection was refused by the server. EPIPE - The remote side of the stream being written has been closed. ENOTFOUND - Could not resolve the hostname to an IP address. ENETUNREACH - No internet connection. EAI_AGAIN - DNS lookup timed out. maxRetryAfter \u00b6 \u7c7b\u578b: number | undefined \u9ed8\u8ba4: options.timeout.request The upper limit of retry-after header . If undefined , it will use options.timeout as the value. If the limit is exceeded, the request is canceled. calculateDelay \u00b6 \u7c7b\u578b: Function 1 ( retryObject : RetryObject ) => Promisable < number > ; 1 2 3 4 5 6 7 interface RetryObject { attemptCount : number ; retryOptions : RetryOptions ; error : RequestError ; computedValue : number ; retryAfter? : number ; } The function used to calculate the delay before the next request is made. Returning 0 cancels the retry. Note: This function is responsible for the entire retry mechanism, including the limit property. To support this, you need to check if computedValue is different than 0 . Tip: This is especially useful when you want to scale down the computed value. 1 2 3 4 5 6 7 8 9 import got from \"got\" ; await got ( \"https://httpbin.org/anything\" , { retry : { calculateDelay : ({ computedValue }) => { return computedValue / 10 ; }, }, }); backoffLimit \u00b6 \u7c7b\u578b: number The upper limit of the computedValue . By default, the computedValue is calculated in the following way: 1 2 ** ( attemptCount - 1 ) * 1000 + noise ; The delay increases exponentially. In order to prevent this, you can set this value to a fixed value, such as 1000 . noise \u00b6 \u7c7b\u578b: number The maximum acceptable retry noise in the range of -100 to +100 .","title":"Retry API"},{"location":"7-retry/#retry-api","text":"Note: If you're looking for retry implementation using streams, check out the Retry Stream API . Tip: You can trigger a retry by throwing the RetryError in any hook. Tip: The afterResponse hook exposes a dedicated function to retry with merged options. Read more .","title":"Retry API"},{"location":"7-retry/#retry","text":"\u7c7b\u578b: object Default: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 { limit : 2 , methods : [ 'GET' , 'PUT' , 'HEAD' , 'DELETE' , 'OPTIONS' , 'TRACE' ], statusCodes : [ 408 , 413 , 429 , 500 , 502 , 503 , 504 , 521 , 522 , 524 ], errorCodes : [ 'ETIMEDOUT' , 'ECONNRESET' , 'EADDRINUSE' , 'ECONNREFUSED' , 'EPIPE' , 'ENOTFOUND' , 'ENETUNREACH' , 'EAI_AGAIN' ], maxRetryAfter : undefined , calculateDelay : ({ computedValue }) => computedValue , backoffLimit : Number . POSITIVE_INFINITY , noise : 100 } This option represents the retry object.","title":"retry"},{"location":"7-retry/#limit","text":"\u7c7b\u578b: number The maximum retry count.","title":"limit"},{"location":"7-retry/#methods","text":"\u7c7b\u578b: string[] The allowed methods to retry on. Note: By default, Got does not retry on POST .","title":"methods"},{"location":"7-retry/#statuscodes","text":"\u7c7b\u578b: number[] Note: Only unsuccessful requests are retried. In order to retry successful requests, use an afterResponse hook. The allowed HTTP status codes to retry on.","title":"statusCodes"},{"location":"7-retry/#errorcodes","text":"\u7c7b\u578b: string[] The allowed error codes to retry on. ETIMEDOUT - One of the timeout limits was reached. ECONNRESET - The connection was forcibly closed. EADDRINUSE - Could not bind to any free port. ECONNREFUSED - The connection was refused by the server. EPIPE - The remote side of the stream being written has been closed. ENOTFOUND - Could not resolve the hostname to an IP address. ENETUNREACH - No internet connection. EAI_AGAIN - DNS lookup timed out.","title":"errorCodes"},{"location":"7-retry/#maxretryafter","text":"\u7c7b\u578b: number | undefined \u9ed8\u8ba4: options.timeout.request The upper limit of retry-after header . If undefined , it will use options.timeout as the value. If the limit is exceeded, the request is canceled.","title":"maxRetryAfter"},{"location":"7-retry/#calculatedelay","text":"\u7c7b\u578b: Function 1 ( retryObject : RetryObject ) => Promisable < number > ; 1 2 3 4 5 6 7 interface RetryObject { attemptCount : number ; retryOptions : RetryOptions ; error : RequestError ; computedValue : number ; retryAfter? : number ; } The function used to calculate the delay before the next request is made. Returning 0 cancels the retry. Note: This function is responsible for the entire retry mechanism, including the limit property. To support this, you need to check if computedValue is different than 0 . Tip: This is especially useful when you want to scale down the computed value. 1 2 3 4 5 6 7 8 9 import got from \"got\" ; await got ( \"https://httpbin.org/anything\" , { retry : { calculateDelay : ({ computedValue }) => { return computedValue / 10 ; }, }, });","title":"calculateDelay"},{"location":"7-retry/#backofflimit","text":"\u7c7b\u578b: number The upper limit of the computedValue . By default, the computedValue is calculated in the following way: 1 2 ** ( attemptCount - 1 ) * 1000 + noise ; The delay increases exponentially. In order to prevent this, you can set this value to a fixed value, such as 1000 .","title":"backoffLimit"},{"location":"7-retry/#noise","text":"\u7c7b\u578b: number The maximum acceptable retry noise in the range of -100 to +100 .","title":"noise"},{"location":"8-errors/","text":"Errors \u00b6 Source code: source/core/errors.ts source/as-promise/types.ts source/core/response.ts All Got errors contain various metadata, such as: code - A string like ERR_NON_2XX_3XX_RESPONSE , options - An instance of Options , request - An instance of Got Stream, response (optional) - An instance of Got Response, timings (optional) - Points to response.timings . Capturing async stack traces \u00b6 Read the article here . Note: The error codes may differ when the root error has a code property set. RequestError \u00b6 Code: ERR_GOT_REQUEST_ERROR When a request fails. Contains a code property with error class code, like ECONNREFUSED . All the errors below inherit this one. CacheError \u00b6 Code: ERR_CACHE_ACCESS When a cache method fails, for example, if the database goes down or there's a filesystem error. ReadError \u00b6 Code: ERR_READING_RESPONSE_STREAM When reading from response stream fails. ParseError \u00b6 Code: ERR_BODY_PARSE_FAILURE When server response code is 2xx, and parsing body fails. Includes a response property. UploadError \u00b6 Code: ERR_UPLOAD When the request body is a stream and an error occurs while reading from that stream. HTTPError \u00b6 Code: ERR_NON_2XX_3XX_RESPONSE When the request is unsuccessful. A request is successful when the status code of the final request is 2xx or 3xx . When following redirects , a request is successful only when the status code of the final request is 2xx . Note: 304 responses are always considered successful. MaxRedirectsError \u00b6 Code: ERR_TOO_MANY_REDIRECTS When the server redirects you more than ten times. Includes a response property. UnsupportedProtocolError \u00b6 Note: This error is not public. Code: ERR_UNSUPPORTED_PROTOCOL When given an unsupported protocol. TimeoutError \u00b6 Code: ETIMEDOUT When the request is aborted due to a timeout . Includes an event (a string) property along with timings . CancelError \u00b6 Code: ERR_CANCELED When the request is aborted with promise.cancel() . RetryError \u00b6 Code: ERR_RETRYING Always triggers a new retry when thrown. AbortError \u00b6 Code: ERR_ABORTED When the request is aborted with AbortController.abort() .","title":"Errors"},{"location":"8-errors/#errors","text":"Source code: source/core/errors.ts source/as-promise/types.ts source/core/response.ts All Got errors contain various metadata, such as: code - A string like ERR_NON_2XX_3XX_RESPONSE , options - An instance of Options , request - An instance of Got Stream, response (optional) - An instance of Got Response, timings (optional) - Points to response.timings .","title":"Errors"},{"location":"8-errors/#capturing-async-stack-traces","text":"Read the article here . Note: The error codes may differ when the root error has a code property set.","title":"Capturing async stack traces"},{"location":"8-errors/#requesterror","text":"Code: ERR_GOT_REQUEST_ERROR When a request fails. Contains a code property with error class code, like ECONNREFUSED . All the errors below inherit this one.","title":"RequestError"},{"location":"8-errors/#cacheerror","text":"Code: ERR_CACHE_ACCESS When a cache method fails, for example, if the database goes down or there's a filesystem error.","title":"CacheError"},{"location":"8-errors/#readerror","text":"Code: ERR_READING_RESPONSE_STREAM When reading from response stream fails.","title":"ReadError"},{"location":"8-errors/#parseerror","text":"Code: ERR_BODY_PARSE_FAILURE When server response code is 2xx, and parsing body fails. Includes a response property.","title":"ParseError"},{"location":"8-errors/#uploaderror","text":"Code: ERR_UPLOAD When the request body is a stream and an error occurs while reading from that stream.","title":"UploadError"},{"location":"8-errors/#httperror","text":"Code: ERR_NON_2XX_3XX_RESPONSE When the request is unsuccessful. A request is successful when the status code of the final request is 2xx or 3xx . When following redirects , a request is successful only when the status code of the final request is 2xx . Note: 304 responses are always considered successful.","title":"HTTPError"},{"location":"8-errors/#maxredirectserror","text":"Code: ERR_TOO_MANY_REDIRECTS When the server redirects you more than ten times. Includes a response property.","title":"MaxRedirectsError"},{"location":"8-errors/#unsupportedprotocolerror","text":"Note: This error is not public. Code: ERR_UNSUPPORTED_PROTOCOL When given an unsupported protocol.","title":"UnsupportedProtocolError"},{"location":"8-errors/#timeouterror","text":"Code: ETIMEDOUT When the request is aborted due to a timeout . Includes an event (a string) property along with timings .","title":"TimeoutError"},{"location":"8-errors/#cancelerror","text":"Code: ERR_CANCELED When the request is aborted with promise.cancel() .","title":"CancelError"},{"location":"8-errors/#retryerror","text":"Code: ERR_RETRYING Always triggers a new retry when thrown.","title":"RetryError"},{"location":"8-errors/#aborterror","text":"Code: ERR_ABORTED When the request is aborted with AbortController.abort() .","title":"AbortError"},{"location":"9-hooks/","text":"Hooks API \u00b6 hooks \u00b6 \u7c7b\u578b: object<string, Function[]> This option represents the hooks to run. Thrown errors will be automatically converted to RequestError . init \u00b6 \u7c7b\u578b: InitHook[] \u9ed8\u8ba4: [] 1 ( plainRequestOptions : OptionsInit , options : Options ) => void Called with the plain request options, right before their normalization. The second argument represents the current Options instance. Note: This hook must be synchronous. Note: This is called every time options are merged. Note: The options object may not have the url property. To modify it, use a beforeRequest hook instead. Note: This hook is called when a new instance of Options is created. Do not confuse this with the creation of Request or got(\u2026) . Note: When using got(url) or got(url, undefined, defaults) this hook will not be called. This is especially useful in conjunction with got.extend() when the input needs custom handling. For example, this can be used to fix typos to migrate from older versions faster. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import got from \"got\" ; const instance = got . extend ({ hooks : { init : [ ( plain ) => { if ( \"followRedirects\" in plain ) { plain . followRedirect = plain . followRedirects ; delete plain . followRedirects ; } }, ], }, }); // Normally, the following would throw: const response = await instance ( \"https://example.com\" , { followRedirects : true , }); // There is no option named `followRedirects`, but we correct it in an `init` hook. Or you can create your own option and store it in a context: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import got from \"got\" ; const instance = got . extend ({ hooks : { init : [ ( plain , options ) => { if ( \"secret\" in plain ) { options . context . secret = plain . secret ; delete plain . secret ; } }, ], beforeRequest : [ ( options ) => { options . headers . secret = options . context . secret ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { secret : \"passphrase\" , }). json (); console . log ( headers . Secret ); //=> 'passphrase' beforeRequest \u00b6 \u7c7b\u578b: BeforeRequestHook[] \u9ed8\u8ba4: [] 1 ( options : Options ) => Promisable < void | Response | ResponseLike > ; Called right before making the request with options.createNativeRequestOptions() . This hook is especially useful in conjunction with got.extend() when you want to sign your request. Note: Got will make no further changes to the request before it is sent. Note: Changing options.json or options.form has no effect on the request. You should change options.body instead. If needed, update the options.headers accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const response = await got . post ( \"https://httpbin.org/anything\" , { json : { payload : \"old\" }, hooks : { beforeRequest : [ ( options ) => { options . body = JSON . stringify ({ payload : \"new\" }); options . headers [ \"content-length\" ] = options . body . length . toString (); }, ], }, }); Tip: You can indirectly override the request function by early returning a ClientRequest -like instance or a IncomingMessage -like instance. This is very useful when creating a custom cache mechanism. Read more about this tip . beforeRedirect \u00b6 \u7c7b\u578b: BeforeRedirectHook[] \u9ed8\u8ba4: [] 1 ( updatedOptions : Options , plainResponse : PlainResponse ) => Promisable < void > ; The equivalent of beforeRequest but when redirecting. Tip: This is especially useful when you want to avoid dead sites. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const response = await got ( \"https://example.com\" , { hooks : { beforeRedirect : [ ( options , response ) => { if ( options . hostname === \"deadSite\" ) { options . hostname = \"fallbackSite\" ; } }, ], }, }); beforeRetry \u00b6 \u7c7b\u578b: BeforeRetryHook[] \u9ed8\u8ba4: [] 1 ( error : RequestError , retryCount : number ) => Promisable < void > ; The equivalent of beforeError but when retrying. Additionally, there is a second argument retryCount , the current retry number. Note: When using the Stream API, this hook is ignored. Note: When retrying, the beforeRequest hook is called afterwards. Note: If no retry occurs, the beforeError hook is called instead. This hook is especially useful when you want to retrieve the cause of a retry. 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; await got ( \"https://httpbin.org/status/500\" , { hooks : { beforeRetry : [ ( error , retryCount ) => { console . log ( `Retrying [ ${ retryCount } ]: ${ error . code } ` ); // Retrying [1]: ERR_NON_2XX_3XX_RESPONSE }, ], }, }); afterResponse \u00b6 \u7c7b\u578b: AfterResponseHook[] \u9ed8\u8ba4: [] 1 2 ( response : Response , retryWithMergedOptions : ( options : OptionsInit ) => never ) => Promisable < Response | CancelableRequest < Response >> ; Each function should return the response. This is especially useful when you want to refresh an access token. Note: When using the Stream API, this hook is ignored. Note: Calling the retryWithMergedOptions function will trigger beforeRetry hooks. If the retry is successful, all remaining afterResponse hooks will be called. In case of an error, beforeRetry hooks will be called instead. Meanwhile the init , beforeRequest , beforeRedirect as well as already executed afterResponse hooks will be skipped. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import got from \"got\" ; const instance = got . extend ({ hooks : { afterResponse : [ ( response , retryWithMergedOptions ) => { // Unauthorized if ( response . statusCode === 401 ) { // Refresh the access token const updatedOptions = { headers : { token : getNewToken (), }, }; // Update the defaults instance . defaults . options . merge ( updatedOptions ); // Make a new retry return retryWithMergedOptions ( updatedOptions ); } // No changes otherwise return response ; }, ], beforeRetry : [ ( error ) => { // This will be called on `retryWithMergedOptions(...)` }, ], }, mutableDefaults : true , }); beforeError \u00b6 \u7c7b\u578b: BeforeErrorHook[] \u9ed8\u8ba4: [] 1 ( error : RequestError ) => Promisable < RequestError > ; Called with a RequestError instance. The error is passed to the hook right before it's thrown. This is especially useful when you want to have more detailed errors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import got from \"got\" ; await got ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { responseType : \"json\" , hooks : { beforeError : [ ( error ) => { const { response } = error ; if ( response && response . body ) { error . name = \"GitHubError\" ; error . message = ` ${ response . body . message } ( ${ response . statusCode } )` ; } return error ; }, ], }, });","title":"Hooks API"},{"location":"9-hooks/#hooks-api","text":"","title":"Hooks API"},{"location":"9-hooks/#hooks","text":"\u7c7b\u578b: object<string, Function[]> This option represents the hooks to run. Thrown errors will be automatically converted to RequestError .","title":"hooks"},{"location":"9-hooks/#init","text":"\u7c7b\u578b: InitHook[] \u9ed8\u8ba4: [] 1 ( plainRequestOptions : OptionsInit , options : Options ) => void Called with the plain request options, right before their normalization. The second argument represents the current Options instance. Note: This hook must be synchronous. Note: This is called every time options are merged. Note: The options object may not have the url property. To modify it, use a beforeRequest hook instead. Note: This hook is called when a new instance of Options is created. Do not confuse this with the creation of Request or got(\u2026) . Note: When using got(url) or got(url, undefined, defaults) this hook will not be called. This is especially useful in conjunction with got.extend() when the input needs custom handling. For example, this can be used to fix typos to migrate from older versions faster. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import got from \"got\" ; const instance = got . extend ({ hooks : { init : [ ( plain ) => { if ( \"followRedirects\" in plain ) { plain . followRedirect = plain . followRedirects ; delete plain . followRedirects ; } }, ], }, }); // Normally, the following would throw: const response = await instance ( \"https://example.com\" , { followRedirects : true , }); // There is no option named `followRedirects`, but we correct it in an `init` hook. Or you can create your own option and store it in a context: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import got from \"got\" ; const instance = got . extend ({ hooks : { init : [ ( plain , options ) => { if ( \"secret\" in plain ) { options . context . secret = plain . secret ; delete plain . secret ; } }, ], beforeRequest : [ ( options ) => { options . headers . secret = options . context . secret ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { secret : \"passphrase\" , }). json (); console . log ( headers . Secret ); //=> 'passphrase'","title":"init"},{"location":"9-hooks/#beforerequest","text":"\u7c7b\u578b: BeforeRequestHook[] \u9ed8\u8ba4: [] 1 ( options : Options ) => Promisable < void | Response | ResponseLike > ; Called right before making the request with options.createNativeRequestOptions() . This hook is especially useful in conjunction with got.extend() when you want to sign your request. Note: Got will make no further changes to the request before it is sent. Note: Changing options.json or options.form has no effect on the request. You should change options.body instead. If needed, update the options.headers accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const response = await got . post ( \"https://httpbin.org/anything\" , { json : { payload : \"old\" }, hooks : { beforeRequest : [ ( options ) => { options . body = JSON . stringify ({ payload : \"new\" }); options . headers [ \"content-length\" ] = options . body . length . toString (); }, ], }, }); Tip: You can indirectly override the request function by early returning a ClientRequest -like instance or a IncomingMessage -like instance. This is very useful when creating a custom cache mechanism. Read more about this tip .","title":"beforeRequest"},{"location":"9-hooks/#beforeredirect","text":"\u7c7b\u578b: BeforeRedirectHook[] \u9ed8\u8ba4: [] 1 ( updatedOptions : Options , plainResponse : PlainResponse ) => Promisable < void > ; The equivalent of beforeRequest but when redirecting. Tip: This is especially useful when you want to avoid dead sites. 1 2 3 4 5 6 7 8 9 10 11 12 13 import got from \"got\" ; const response = await got ( \"https://example.com\" , { hooks : { beforeRedirect : [ ( options , response ) => { if ( options . hostname === \"deadSite\" ) { options . hostname = \"fallbackSite\" ; } }, ], }, });","title":"beforeRedirect"},{"location":"9-hooks/#beforeretry","text":"\u7c7b\u578b: BeforeRetryHook[] \u9ed8\u8ba4: [] 1 ( error : RequestError , retryCount : number ) => Promisable < void > ; The equivalent of beforeError but when retrying. Additionally, there is a second argument retryCount , the current retry number. Note: When using the Stream API, this hook is ignored. Note: When retrying, the beforeRequest hook is called afterwards. Note: If no retry occurs, the beforeError hook is called instead. This hook is especially useful when you want to retrieve the cause of a retry. 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; await got ( \"https://httpbin.org/status/500\" , { hooks : { beforeRetry : [ ( error , retryCount ) => { console . log ( `Retrying [ ${ retryCount } ]: ${ error . code } ` ); // Retrying [1]: ERR_NON_2XX_3XX_RESPONSE }, ], }, });","title":"beforeRetry"},{"location":"9-hooks/#afterresponse","text":"\u7c7b\u578b: AfterResponseHook[] \u9ed8\u8ba4: [] 1 2 ( response : Response , retryWithMergedOptions : ( options : OptionsInit ) => never ) => Promisable < Response | CancelableRequest < Response >> ; Each function should return the response. This is especially useful when you want to refresh an access token. Note: When using the Stream API, this hook is ignored. Note: Calling the retryWithMergedOptions function will trigger beforeRetry hooks. If the retry is successful, all remaining afterResponse hooks will be called. In case of an error, beforeRetry hooks will be called instead. Meanwhile the init , beforeRequest , beforeRedirect as well as already executed afterResponse hooks will be skipped. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import got from \"got\" ; const instance = got . extend ({ hooks : { afterResponse : [ ( response , retryWithMergedOptions ) => { // Unauthorized if ( response . statusCode === 401 ) { // Refresh the access token const updatedOptions = { headers : { token : getNewToken (), }, }; // Update the defaults instance . defaults . options . merge ( updatedOptions ); // Make a new retry return retryWithMergedOptions ( updatedOptions ); } // No changes otherwise return response ; }, ], beforeRetry : [ ( error ) => { // This will be called on `retryWithMergedOptions(...)` }, ], }, mutableDefaults : true , });","title":"afterResponse"},{"location":"9-hooks/#beforeerror","text":"\u7c7b\u578b: BeforeErrorHook[] \u9ed8\u8ba4: [] 1 ( error : RequestError ) => Promisable < RequestError > ; Called with a RequestError instance. The error is passed to the hook right before it's thrown. This is especially useful when you want to have more detailed errors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import got from \"got\" ; await got ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { responseType : \"json\" , hooks : { beforeError : [ ( error ) => { const { response } = error ; if ( response && response . body ) { error . name = \"GitHubError\" ; error . message = ` ${ response . body . message } ( ${ response . statusCode } )` ; } return error ; }, ], }, });","title":"beforeError"},{"location":"async-stack-traces/","text":"\u6355\u83b7\u5f02\u6b65\u5806\u6808\u8ddf\u8e2a \u00b6 Caution: \u6355\u83b7\u5f02\u6b65\u5806\u6808\u8ddf\u8e2a\u4f1a\u4e25\u91cd\u964d\u4f4e\u6027\u80fd! \u60f3\u8df3\u8fc7\u8fd9\u7bc7\u6587\u7ae0?\u8bf7\u53c2\u9605 Conclusion \uff0c\u6211\u4eec\u5728\u5176\u4e2d\u8ba8\u8bba\u4e86\u4e00\u4e2a\u666e\u901a\u7684\u89e3\u51b3\u65b9\u6848\u3002 \u6211\u4eec\u751f\u6d3b\u5728\u4e00\u4e2a\u5145\u6ee1\u866b\u5b50\u7684\u4e16\u754c\u3002 \u8f6f\u4ef6\u53d8\u5f97\u8d8a\u6765\u8d8a\u590d\u6742\uff0c\u8fd9\u4f7f\u5f97\u8c03\u8bd5\u53d8\u5f97\u8d8a\u6765\u8d8a\u56f0\u96be\u3002 \u4f60\u662f\u5426\u66fe\u7ecf\u72af\u8fc7\u9519\u8bef\uff0c\u5374\u4e0d\u77e5\u9053\u9519\u8bef\u6765\u81ea\u54ea\u91cc?\u662f\u7684\uff0c\u901a\u5e38\u4e0d\u5bb9\u6613\u627e\u5230\u3002 \u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230\uff0c\u9519\u8bef\u7684 .stack \u6709\u65f6\u770b\u8d77\u6765\u4e0d\u5b8c\u6574\u3002 \u8fd9\u901a\u5e38\u662f\u7531\u4e8e\u8ba1\u65f6\u5668\u89e6\u53d1\u7684\u5f02\u6b65\u51fd\u6570\u7684\u6267\u884c\u3002 \u793a\u4f8b\u5982\u4e0b: 1 2 3 4 5 await new Promise (( resolve , reject ) => { setTimeout (() => { reject ( new Error ( \"here\" )); }); }); 1 2 3 4 5 6 7 8 file : ///home/szm/Desktop/got/demo.js:3 reject ( new Error ( 'here' )); ^ Error : here at Timeout . _onTimeout ( file : ///home/szm/Desktop/got/demo.js:3:10) at listOnTimeout ( node : internal / timers : 557 : 17 ) at processTimers ( node : internal / timers : 500 : 7 ) The stack trace does not show where the timeout was set. It's currently not possible to determine this with the native Promise s. However, bluebird exposes an option dedicated to capturing async stack traces: 1 2 3 4 5 6 7 8 9 10 import Bluebird from \"bluebird\" ; Bluebird . config ({ longStackTraces : true }); global . Promise = Bluebird ; await new Promise (( resolve , reject ) => { setTimeout (() => { reject ( new Error ( \"here\" )); }); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node:internal/process/esm_loader:74 internalBinding('errors').triggerUncaughtException( ^ Error: here at Timeout._onTimeout (file:///home/szm/Desktop/got/demo.js:7:10) at listOnTimeout (node:internal/timers:557:17) at processTimers (node:internal/timers:500:7) From previous event: at file:///home/szm/Desktop/got/demo.js:5:7 at ModuleJob.run (node:internal/modules/esm/module_job:183:25) at async Loader.import (node:internal/modules/esm/loader:178:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) at async handleMainPromise (node:internal/modules/run_main:63:12) Now it's clear. We know that the timeout was set on line 5. Bluebird should be sufficient for Got: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import Bluebird from \"bluebird\" ; import got from \"got\" ; Bluebird . config ({ longStackTraces : true }); global . Promise = Bluebird ; try { await got ( \"https://httpbin.org/delay/1\" , { timeout : { request : 1 , }, retry : { limit : 0 , }, }); } catch ( error ) { console . error ( error . stack ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 TimeoutError: Timeout awaiting 'request' for 1ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) From previous event: at new PCancelable (file:///home/szm/Desktop/got/node_modules/p-cancelable/index.js:31:19) at asPromise (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:21:21) at lastHandler (file:///home/szm/Desktop/got/dist/source/create.js:42:27) at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28) at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16) at file:///home/szm/Desktop/got/demo.js:8:8 at ModuleJob.run (node:internal/modules/esm/module_job:183:25) at async Loader.import (node:internal/modules/esm/loader:178:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) at async handleMainPromise (node:internal/modules/run_main:63:12) As expected, we know where the timeout has been set. Unfortunately, if we increase our retry count limit to 1 , the stack trace remains the same. That's because bluebird doesn't track I/O events. Please note that this should be sufficient for most cases. In order to debug further, we can use async_hooks instead. A Stack Overflow user has come up with an awesome solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import asyncHooks from \"async_hooks\" ; const traces = new Map (); asyncHooks . createHook ({ init ( id ) { const trace = {}; Error . captureStackTrace ( trace ); traces . set ( id , trace . stack . replace ( /(^.+$\\n){4}/m , \"\\n\" )); }, destroy ( id ) { traces . delete ( id ); }, }) . enable (); globalThis . Error = class extends Error { constructor ( message ) { super ( message ); this . constructor . captureStackTrace ( this , this . constructor ); } static captureStackTrace ( what , where ) { super . captureStackTrace . call ( Error , what , where ); const trace = traces . get ( asyncHooks . executionAsyncId ()); if ( trace ) { what . stack += trace ; } } }; If we replace the bluebird part with this, we get: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 Error: Timeout awaiting 'request' for 1ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at emitInitScript (node:internal/async_hooks:493:3) at process.nextTick (node:internal/process/task_queues:133:5) at onDestroy (node:internal/streams/destroy:96:15) at TLSSocket.Socket._destroy (node:net:677:5) at _destroy (node:internal/streams/destroy:102:25) at TLSSocket.destroy (node:internal/streams/destroy:64:5) at ClientRequest.destroy (node:_http_client:371:16) at emitInitScript (node:internal/async_hooks:493:3) at initAsyncResource (node:internal/timers:162:5) at new Timeout (node:internal/timers:196:3) at setTimeout (node:timers:164:19) at addTimeout (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:32:25) at timedOut (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:59:31) at Request._onRequest (file:///home/szm/Desktop/got/dist/source/core/index.js:771:32) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at Request.flush (file:///home/szm/Desktop/got/dist/source/core/index.js:274:24) at makeRequest (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:125:30) at Request.<anonymous> (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:121:17) at Object.onceWrapper (node:events:514:26) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at file:///home/szm/Desktop/got/dist/source/core/index.js:357:27 at processTicksAndRejections (node:internal/process/task_queues:96:5) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at file:///home/szm/Desktop/got/dist/source/core/index.js:338:50 at Request._beforeError (file:///home/szm/Desktop/got/dist/source/core/index.js:388:11) at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:781:18) at Object.onceWrapper (node:events:514:26) at emitInitScript (node:internal/async_hooks:493:3) at process.nextTick (node:internal/process/task_queues:133:5) at onDestroy (node:internal/streams/destroy:96:15) at TLSSocket.Socket._destroy (node:net:677:5) at _destroy (node:internal/streams/destroy:102:25) at TLSSocket.destroy (node:internal/streams/destroy:64:5) at ClientRequest.destroy (node:_http_client:371:16) at emitInitScript (node:internal/async_hooks:493:3) at initAsyncResource (node:internal/timers:162:5) at new Timeout (node:internal/timers:196:3) at setTimeout (node:timers:164:19) at addTimeout (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:32:25) at timedOut (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:59:31) at Request._onRequest (file:///home/szm/Desktop/got/dist/source/core/index.js:771:32) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at Request.flush (file:///home/szm/Desktop/got/dist/source/core/index.js:274:24) at lastHandler (file:///home/szm/Desktop/got/dist/source/create.js:37:26) at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28) at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) This is extremely long, and not a complete Node.js app. Just a demo. Imagine how long it would be if this was used with databases, file systems, etc. Conclusion \u00b6 All these workarounds have a large impact on performance. However, there is a possible solution to this madness. Got provides handlers, hooks, and context. We can capture the stack trace in a handler, store it in a context and expose it in a beforeError hook. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import got from \"got\" ; const instance = got . extend ({ handlers : [ ( options , next ) => { Error . captureStackTrace ( options . context ); return next ( options ); }, ], hooks : { beforeError : [ ( error ) => { error . source = error . options . context . stack . split ( \"\\n\" ); return error ; }, ], }, }); try { await instance ( \"https://httpbin.org/delay/1\" , { timeout : { request : 100 , }, retry : { limit : 0 , }, }); } catch ( error ) { console . error ( error ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 RequestError: Timeout awaiting 'request' for 100ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) { input: undefined, code: 'ETIMEDOUT', timings: { <too long to include> }, name: 'TimeoutError', options: { <too long to include> }, event: 'request', source: [ 'Error', ' at got.extend.handlers (file:///home/szm/Desktop/got/demo.js:6:10)', ' at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28)', ' at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16)', ' at file:///home/szm/Desktop/got/demo.js:23:8', ' at ModuleJob.run (node:internal/modules/esm/module_job:183:25)', ' at async Loader.import (node:internal/modules/esm/loader:178:24)', ' at async Object.loadESM (node:internal/process/esm_loader:68:5)', ' at async handleMainPromise (node:internal/modules/run_main:63:12)' ] } Yay! This is much more readable. Furthermore, we capture the stack trace only when got is called. This is definitely going to have some performance impact, but it will be much more performant than the other mentioned solutions. Curious to know more? Check out these links: https://stackoverflow.com/questions/54914770/is-there-a-good-way-to-surface-error-traces-in-production-across-event-emitters https://github.com/nodejs/node/issues/11370 https://github.com/puppeteer/puppeteer/issues/2037 https://github.com/nodejs/node/pull/13870","title":"\u6355\u83b7\u5f02\u6b65\u5806\u6808\u8ddf\u8e2a"},{"location":"async-stack-traces/#_1","text":"Caution: \u6355\u83b7\u5f02\u6b65\u5806\u6808\u8ddf\u8e2a\u4f1a\u4e25\u91cd\u964d\u4f4e\u6027\u80fd! \u60f3\u8df3\u8fc7\u8fd9\u7bc7\u6587\u7ae0?\u8bf7\u53c2\u9605 Conclusion \uff0c\u6211\u4eec\u5728\u5176\u4e2d\u8ba8\u8bba\u4e86\u4e00\u4e2a\u666e\u901a\u7684\u89e3\u51b3\u65b9\u6848\u3002 \u6211\u4eec\u751f\u6d3b\u5728\u4e00\u4e2a\u5145\u6ee1\u866b\u5b50\u7684\u4e16\u754c\u3002 \u8f6f\u4ef6\u53d8\u5f97\u8d8a\u6765\u8d8a\u590d\u6742\uff0c\u8fd9\u4f7f\u5f97\u8c03\u8bd5\u53d8\u5f97\u8d8a\u6765\u8d8a\u56f0\u96be\u3002 \u4f60\u662f\u5426\u66fe\u7ecf\u72af\u8fc7\u9519\u8bef\uff0c\u5374\u4e0d\u77e5\u9053\u9519\u8bef\u6765\u81ea\u54ea\u91cc?\u662f\u7684\uff0c\u901a\u5e38\u4e0d\u5bb9\u6613\u627e\u5230\u3002 \u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230\uff0c\u9519\u8bef\u7684 .stack \u6709\u65f6\u770b\u8d77\u6765\u4e0d\u5b8c\u6574\u3002 \u8fd9\u901a\u5e38\u662f\u7531\u4e8e\u8ba1\u65f6\u5668\u89e6\u53d1\u7684\u5f02\u6b65\u51fd\u6570\u7684\u6267\u884c\u3002 \u793a\u4f8b\u5982\u4e0b: 1 2 3 4 5 await new Promise (( resolve , reject ) => { setTimeout (() => { reject ( new Error ( \"here\" )); }); }); 1 2 3 4 5 6 7 8 file : ///home/szm/Desktop/got/demo.js:3 reject ( new Error ( 'here' )); ^ Error : here at Timeout . _onTimeout ( file : ///home/szm/Desktop/got/demo.js:3:10) at listOnTimeout ( node : internal / timers : 557 : 17 ) at processTimers ( node : internal / timers : 500 : 7 ) The stack trace does not show where the timeout was set. It's currently not possible to determine this with the native Promise s. However, bluebird exposes an option dedicated to capturing async stack traces: 1 2 3 4 5 6 7 8 9 10 import Bluebird from \"bluebird\" ; Bluebird . config ({ longStackTraces : true }); global . Promise = Bluebird ; await new Promise (( resolve , reject ) => { setTimeout (() => { reject ( new Error ( \"here\" )); }); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node:internal/process/esm_loader:74 internalBinding('errors').triggerUncaughtException( ^ Error: here at Timeout._onTimeout (file:///home/szm/Desktop/got/demo.js:7:10) at listOnTimeout (node:internal/timers:557:17) at processTimers (node:internal/timers:500:7) From previous event: at file:///home/szm/Desktop/got/demo.js:5:7 at ModuleJob.run (node:internal/modules/esm/module_job:183:25) at async Loader.import (node:internal/modules/esm/loader:178:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) at async handleMainPromise (node:internal/modules/run_main:63:12) Now it's clear. We know that the timeout was set on line 5. Bluebird should be sufficient for Got: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import Bluebird from \"bluebird\" ; import got from \"got\" ; Bluebird . config ({ longStackTraces : true }); global . Promise = Bluebird ; try { await got ( \"https://httpbin.org/delay/1\" , { timeout : { request : 1 , }, retry : { limit : 0 , }, }); } catch ( error ) { console . error ( error . stack ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 TimeoutError: Timeout awaiting 'request' for 1ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) From previous event: at new PCancelable (file:///home/szm/Desktop/got/node_modules/p-cancelable/index.js:31:19) at asPromise (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:21:21) at lastHandler (file:///home/szm/Desktop/got/dist/source/create.js:42:27) at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28) at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16) at file:///home/szm/Desktop/got/demo.js:8:8 at ModuleJob.run (node:internal/modules/esm/module_job:183:25) at async Loader.import (node:internal/modules/esm/loader:178:24) at async Object.loadESM (node:internal/process/esm_loader:68:5) at async handleMainPromise (node:internal/modules/run_main:63:12) As expected, we know where the timeout has been set. Unfortunately, if we increase our retry count limit to 1 , the stack trace remains the same. That's because bluebird doesn't track I/O events. Please note that this should be sufficient for most cases. In order to debug further, we can use async_hooks instead. A Stack Overflow user has come up with an awesome solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import asyncHooks from \"async_hooks\" ; const traces = new Map (); asyncHooks . createHook ({ init ( id ) { const trace = {}; Error . captureStackTrace ( trace ); traces . set ( id , trace . stack . replace ( /(^.+$\\n){4}/m , \"\\n\" )); }, destroy ( id ) { traces . delete ( id ); }, }) . enable (); globalThis . Error = class extends Error { constructor ( message ) { super ( message ); this . constructor . captureStackTrace ( this , this . constructor ); } static captureStackTrace ( what , where ) { super . captureStackTrace . call ( Error , what , where ); const trace = traces . get ( asyncHooks . executionAsyncId ()); if ( trace ) { what . stack += trace ; } } }; If we replace the bluebird part with this, we get: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 Error: Timeout awaiting 'request' for 1ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at emitInitScript (node:internal/async_hooks:493:3) at process.nextTick (node:internal/process/task_queues:133:5) at onDestroy (node:internal/streams/destroy:96:15) at TLSSocket.Socket._destroy (node:net:677:5) at _destroy (node:internal/streams/destroy:102:25) at TLSSocket.destroy (node:internal/streams/destroy:64:5) at ClientRequest.destroy (node:_http_client:371:16) at emitInitScript (node:internal/async_hooks:493:3) at initAsyncResource (node:internal/timers:162:5) at new Timeout (node:internal/timers:196:3) at setTimeout (node:timers:164:19) at addTimeout (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:32:25) at timedOut (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:59:31) at Request._onRequest (file:///home/szm/Desktop/got/dist/source/core/index.js:771:32) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at Request.flush (file:///home/szm/Desktop/got/dist/source/core/index.js:274:24) at makeRequest (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:125:30) at Request.<anonymous> (file:///home/szm/Desktop/got/dist/source/as-promise/index.js:121:17) at Object.onceWrapper (node:events:514:26) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at file:///home/szm/Desktop/got/dist/source/core/index.js:357:27 at processTicksAndRejections (node:internal/process/task_queues:96:5) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at file:///home/szm/Desktop/got/dist/source/core/index.js:338:50 at Request._beforeError (file:///home/szm/Desktop/got/dist/source/core/index.js:388:11) at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:781:18) at Object.onceWrapper (node:events:514:26) at emitInitScript (node:internal/async_hooks:493:3) at process.nextTick (node:internal/process/task_queues:133:5) at onDestroy (node:internal/streams/destroy:96:15) at TLSSocket.Socket._destroy (node:net:677:5) at _destroy (node:internal/streams/destroy:102:25) at TLSSocket.destroy (node:internal/streams/destroy:64:5) at ClientRequest.destroy (node:_http_client:371:16) at emitInitScript (node:internal/async_hooks:493:3) at initAsyncResource (node:internal/timers:162:5) at new Timeout (node:internal/timers:196:3) at setTimeout (node:timers:164:19) at addTimeout (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:32:25) at timedOut (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:59:31) at Request._onRequest (file:///home/szm/Desktop/got/dist/source/core/index.js:771:32) at emitInitScript (node:internal/async_hooks:493:3) at promiseInitHook (node:internal/async_hooks:323:3) at promiseInitHookWithDestroyTracking (node:internal/async_hooks:327:3) at Request.flush (file:///home/szm/Desktop/got/dist/source/core/index.js:274:24) at lastHandler (file:///home/szm/Desktop/got/dist/source/create.js:37:26) at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28) at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) This is extremely long, and not a complete Node.js app. Just a demo. Imagine how long it would be if this was used with databases, file systems, etc.","title":"\u6355\u83b7\u5f02\u6b65\u5806\u6808\u8ddf\u8e2a"},{"location":"async-stack-traces/#conclusion","text":"All these workarounds have a large impact on performance. However, there is a possible solution to this madness. Got provides handlers, hooks, and context. We can capture the stack trace in a handler, store it in a context and expose it in a beforeError hook. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import got from \"got\" ; const instance = got . extend ({ handlers : [ ( options , next ) => { Error . captureStackTrace ( options . context ); return next ( options ); }, ], hooks : { beforeError : [ ( error ) => { error . source = error . options . context . stack . split ( \"\\n\" ); return error ; }, ], }, }); try { await instance ( \"https://httpbin.org/delay/1\" , { timeout : { request : 100 , }, retry : { limit : 0 , }, }); } catch ( error ) { console . error ( error ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 RequestError: Timeout awaiting 'request' for 100ms at ClientRequest.<anonymous> (file:///home/szm/Desktop/got/dist/source/core/index.js:780:61) at Object.onceWrapper (node:events:514:26) at ClientRequest.emit (node:events:406:35) at TLSSocket.socketErrorListener (node:_http_client:447:9) at TLSSocket.emit (node:events:394:28) at emitErrorNT (node:internal/streams/destroy:157:8) at emitErrorCloseNT (node:internal/streams/destroy:122:3) at processTicksAndRejections (node:internal/process/task_queues:83:21) at Timeout.timeoutHandler [as _onTimeout] (file:///home/szm/Desktop/got/dist/source/core/timed-out.js:42:25) at listOnTimeout (node:internal/timers:559:11) at processTimers (node:internal/timers:500:7) { input: undefined, code: 'ETIMEDOUT', timings: { <too long to include> }, name: 'TimeoutError', options: { <too long to include> }, event: 'request', source: [ 'Error', ' at got.extend.handlers (file:///home/szm/Desktop/got/demo.js:6:10)', ' at iterateHandlers (file:///home/szm/Desktop/got/dist/source/create.js:49:28)', ' at got (file:///home/szm/Desktop/got/dist/source/create.js:69:16)', ' at file:///home/szm/Desktop/got/demo.js:23:8', ' at ModuleJob.run (node:internal/modules/esm/module_job:183:25)', ' at async Loader.import (node:internal/modules/esm/loader:178:24)', ' at async Object.loadESM (node:internal/process/esm_loader:68:5)', ' at async handleMainPromise (node:internal/modules/run_main:63:12)' ] } Yay! This is much more readable. Furthermore, we capture the stack trace only when got is called. This is definitely going to have some performance impact, but it will be much more performant than the other mentioned solutions. Curious to know more? Check out these links: https://stackoverflow.com/questions/54914770/is-there-a-good-way-to-surface-error-traces-in-production-across-event-emitters https://github.com/nodejs/node/issues/11370 https://github.com/puppeteer/puppeteer/issues/2037 https://github.com/nodejs/node/pull/13870","title":"Conclusion"},{"location":"cache/","text":"\u7f13\u5b58 \u00b6 Got implements RFC 7234 compliant HTTP caching which works out of the box in-memory and is easily pluggable with a wide range of storage adapters. Fresh cache entries are served directly from the cache, and stale cache entries are revalidated with If-None-Match / If-Modified-Since headers. You can read more about the underlying cache behavior in the cacheable-request documentation . You can use the JavaScript Map type as an in-memory cache: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const map = new Map (); let response = await got ( \"https://sindresorhus.com\" , { cache : map }); console . log ( response . isFromCache ); //=> false response = await got ( \"https://sindresorhus.com\" , { cache : map }); console . log ( response . isFromCache ); //=> true Got uses Keyv internally to support a wide range of storage adapters. For something more scalable you could use an official Keyv storage adapter : 1 $ npm install @keyv/redis 1 2 3 4 5 6 import got from \"got\" ; import KeyvRedis from \"@keyv/redis\" ; const redis = new KeyvRedis ( \"redis://user:pass@localhost:6379\" ); await got ( \"https://sindresorhus.com\" , { cache : redis }); Got supports anything that follows the Map API, so it's easy to write your own storage adapter or use a third-party solution. For example, the following are all valid storage adapters: 1 2 3 const storageAdapter = new Map (); await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); 1 2 3 import storageAdapter from \"./my-storage-adapter\" ; await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); 1 2 3 4 5 import QuickLRU from \"quick-lru\" ; const storageAdapter = new QuickLRU ({ maxSize : 1000 }); await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); View the Keyv docs for more information on how to use storage adapters. Advanced caching mechanisms \u00b6 The request function may return an instance of IncomingMessage -like class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import https from \"node:https\" ; import { Readable } from \"node:stream\" ; import got from \"got\" ; const getCachedResponse = ( url , options ) => { const response = new Readable ({ read () { this . push ( \"Hello, world!\" ); this . push ( null ); }, }); response . statusCode = 200 ; response . headers = {}; response . trailers = {}; response . socket = null ; response . aborted = false ; response . complete = true ; response . httpVersion = \"1.1\" ; response . httpVersionMinor = 1 ; response . httpVersionMajor = 1 ; return response ; }; const instance = got . extend ({ request : ( url , options , callback ) => { return getCachedResponse ( url , options ); }, }); const body = await instance ( \"https://example.com\" ). text (); console . log ( body ); //=> \"Hello, world!\" If you don't want to alter the request function, you can return a cached response in a beforeRequest hook: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import https from \"node:https\" ; import { Readable } from \"node:stream\" ; import got from \"got\" ; const getCachedResponse = ( url , options ) => { const response = new Readable ({ read () { this . push ( \"Hello, world!\" ); this . push ( null ); }, }); response . statusCode = 200 ; response . headers = {}; response . trailers = {}; response . socket = null ; response . aborted = false ; response . complete = true ; response . httpVersion = \"1.1\" ; response . httpVersionMinor = 1 ; response . httpVersionMajor = 1 ; return response ; }; const instance = got . extend ({ hooks : { beforeRequest : [ ( options ) => { return getCachedResponse ( options . url , options ); }, ], }, }); const body = await instance ( \"https://example.com\" ). text (); console . log ( body ); //=> \"Hello, world!\" If you want to prevent duplicating the same requests, you can use a handler instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import got from \"got\" ; const map = new Map (); const instance = got . extend ({ handlers : [ ( options , next ) => { if ( options . isStream ) { return next ( options ); } const pending = map . get ( options . url . href ); if ( pending ) { return pending ; } const promise = next ( options ); map . set ( options . url . href , promise ); promise . finally (() => { map . delete ( options . url . href ); }); return promise ; }, ], }); const [ first , second ] = await Promise . all ([ instance ( \"https://httpbin.org/anything\" ), instance ( \"https://httpbin.org/anything\" ), ]); console . log ( first === second ); //=> true","title":"\u7f13\u5b58"},{"location":"cache/#_1","text":"Got implements RFC 7234 compliant HTTP caching which works out of the box in-memory and is easily pluggable with a wide range of storage adapters. Fresh cache entries are served directly from the cache, and stale cache entries are revalidated with If-None-Match / If-Modified-Since headers. You can read more about the underlying cache behavior in the cacheable-request documentation . You can use the JavaScript Map type as an in-memory cache: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const map = new Map (); let response = await got ( \"https://sindresorhus.com\" , { cache : map }); console . log ( response . isFromCache ); //=> false response = await got ( \"https://sindresorhus.com\" , { cache : map }); console . log ( response . isFromCache ); //=> true Got uses Keyv internally to support a wide range of storage adapters. For something more scalable you could use an official Keyv storage adapter : 1 $ npm install @keyv/redis 1 2 3 4 5 6 import got from \"got\" ; import KeyvRedis from \"@keyv/redis\" ; const redis = new KeyvRedis ( \"redis://user:pass@localhost:6379\" ); await got ( \"https://sindresorhus.com\" , { cache : redis }); Got supports anything that follows the Map API, so it's easy to write your own storage adapter or use a third-party solution. For example, the following are all valid storage adapters: 1 2 3 const storageAdapter = new Map (); await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); 1 2 3 import storageAdapter from \"./my-storage-adapter\" ; await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); 1 2 3 4 5 import QuickLRU from \"quick-lru\" ; const storageAdapter = new QuickLRU ({ maxSize : 1000 }); await got ( \"https://sindresorhus.com\" , { cache : storageAdapter }); View the Keyv docs for more information on how to use storage adapters.","title":"\u7f13\u5b58"},{"location":"cache/#advanced-caching-mechanisms","text":"The request function may return an instance of IncomingMessage -like class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import https from \"node:https\" ; import { Readable } from \"node:stream\" ; import got from \"got\" ; const getCachedResponse = ( url , options ) => { const response = new Readable ({ read () { this . push ( \"Hello, world!\" ); this . push ( null ); }, }); response . statusCode = 200 ; response . headers = {}; response . trailers = {}; response . socket = null ; response . aborted = false ; response . complete = true ; response . httpVersion = \"1.1\" ; response . httpVersionMinor = 1 ; response . httpVersionMajor = 1 ; return response ; }; const instance = got . extend ({ request : ( url , options , callback ) => { return getCachedResponse ( url , options ); }, }); const body = await instance ( \"https://example.com\" ). text (); console . log ( body ); //=> \"Hello, world!\" If you don't want to alter the request function, you can return a cached response in a beforeRequest hook: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import https from \"node:https\" ; import { Readable } from \"node:stream\" ; import got from \"got\" ; const getCachedResponse = ( url , options ) => { const response = new Readable ({ read () { this . push ( \"Hello, world!\" ); this . push ( null ); }, }); response . statusCode = 200 ; response . headers = {}; response . trailers = {}; response . socket = null ; response . aborted = false ; response . complete = true ; response . httpVersion = \"1.1\" ; response . httpVersionMinor = 1 ; response . httpVersionMajor = 1 ; return response ; }; const instance = got . extend ({ hooks : { beforeRequest : [ ( options ) => { return getCachedResponse ( options . url , options ); }, ], }, }); const body = await instance ( \"https://example.com\" ). text (); console . log ( body ); //=> \"Hello, world!\" If you want to prevent duplicating the same requests, you can use a handler instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import got from \"got\" ; const map = new Map (); const instance = got . extend ({ handlers : [ ( options , next ) => { if ( options . isStream ) { return next ( options ); } const pending = map . get ( options . url . href ); if ( pending ) { return pending ; } const promise = next ( options ); map . set ( options . url . href , promise ); promise . finally (() => { map . delete ( options . url . href ); }); return promise ; }, ], }); const [ first , second ] = await Promise . all ([ instance ( \"https://httpbin.org/anything\" ), instance ( \"https://httpbin.org/anything\" ), ]); console . log ( first === second ); //=> true","title":"Advanced caching mechanisms"},{"location":"lets-make-a-plugin/","text":"\u63d2\u4ef6 \u00b6 \u53e6\u4e00\u4e2a\u5173\u4e8e\u5982\u4f55\u50cf\u8001\u677f\u4e00\u6837\u4f7f\u7528 Got \u7684\u4f8b\u5b50 \u597d\u4e86\uff0c\u4f60\u4eec\u5df2\u7ecf\u5b66\u4e86\u4e00\u4e9b\u57fa\u7840\u77e5\u8bc6\u3002\u592a\u597d\u4e86! When it comes to advanced usage, custom instances are really helpful. For example, take a look at gh-got . It looks pretty complicated, but... it's simple and extremely useful. Before we start, we need to find the GitHub API docs . Let's write down the most important information: The root endpoint is https://api.github.com/ . We will use version 3 of the API.\\ The Accept header needs to be set to application/vnd.github.v3+json . The body is in a JSON format. We will use OAuth2 for authorization. We may receive 400 Bad Request or 422 Unprocessable Entity .\\ The body contains detailed information about the error. Pagination? Yeah! Supported natively by Got. Rate limiting. These headers are interesting: X-RateLimit-Limit X-RateLimit-Remaining X-RateLimit-Reset Also X-GitHub-Request-Id may be useful for debugging. The User-Agent header is required. When we have all the necessary info, we can start mixing \u6839\u7aef\u70b9 \u00b6 Not much to do here. Just extend an instance and provide the prefixUrl option: 1 2 3 4 5 6 7 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , }); export default instance ; v3 API \u00b6 GitHub needs to know which API version we are using. We'll use the Accept header for that: 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, }); export default instance ; JSON body \u00b6 We'll use options.responseType : 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , }); export default instance ; \u6388\u6743 \u00b6 It's common to set some environment variables, for example, GITHUB_TOKEN . You can modify the tokens in all your apps easily, right? Cool. What about... we want to provide a unique token for each app. Then we will need to create a new option - it will default to the environment variable, but you can easily override it. Got performs option validation and doesn't know that token is a wanted option so it will throw. We can handle it inside an init hook and save it in options.context . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , context : { token : process . env . GITHUB_TOKEN , }, hooks : { init : [ ( raw , options ) => { if ( \"token\" in raw ) { options . context . token = raw . token ; delete raw . token ; } }, ], }, }); export default instance ; For the rest we will use a handler. We could use hooks, but this way it will be more readable. Having beforeRequest , beforeError and afterResponse hooks for just a few lines of code would complicate things unnecessarily. Tip: It's a good practice to use hooks when your plugin gets complicated. Try not to overload the handler function, but don't abuse hooks either. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , context : { token : process . env . GITHUB_TOKEN , }, hooks : { init : [ ( raw , options ) => { if ( \"token\" in raw ) { options . context . token = raw . token ; delete raw . token ; } }, ], }, handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } return next ( options ); }, ], }); export default instance ; \u9519\u8bef \u00b6 We should name our errors, just to know if the error is from the API response. Superb errors, here we come! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ... handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } // Don't touch streams if ( options . isStream ) { return next ( options ); } // Magic begins return ( async () => { try { const response = await next ( options ); return response ; } catch ( error ) { const { response } = error ; // Nicer errors if ( response && response . body ) { error . name = 'GitHubError' ; error . message = ` ${ response . body . message } ( ${ response . statusCode } status code)` ; } throw error ; } })(); } ] ... Note that by providing our own errors in handlers, we don't alter the ones in beforeError hooks.\\ The conversion is the last thing here. \u901f\u5ea6\u9650\u5236 \u00b6 Umm... response.headers['x-ratelimit-remaining'] doesn't look good. What about response.rateLimit.limit instead?\\ Yeah, definitely. Since response.headers is an object, we can easily parse these: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const getRateLimit = ( headers ) => ({ limit : Number . parseInt ( headers [ \"x-ratelimit-limit\" ], 10 ), remaining : Number . parseInt ( headers [ \"x-ratelimit-remaining\" ], 10 ), reset : new Date ( Number . parseInt ( headers [ \"x-ratelimit-reset\" ], 10 ) * 1000 ), }); getRateLimit ({ \"x-ratelimit-limit\" : \"60\" , \"x-ratelimit-remaining\" : \"55\" , \"x-ratelimit-reset\" : \"1562852139\" , }); // => { // limit: 60, // remaining: 55, // reset: 2019-07-11T13:35:39.000Z // } Let's integrate it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const getRateLimit = ( headers ) => ({ limit : Number . parseInt ( headers [ 'x-ratelimit-limit' ], 10 ), remaining : Number . parseInt ( headers [ 'x-ratelimit-remaining' ], 10 ), reset : new Date ( Number . parseInt ( headers [ 'x-ratelimit-reset' ], 10 ) * 1000 ) }); ... handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } // Don't touch streams if ( options . isStream ) { return next ( options ); } // Magic begins return ( async () => { try { const response = await next ( options ); // Rate limit for the Response object response . rateLimit = getRateLimit ( response . headers ); return response ; } catch ( error ) { const { response } = error ; // Nicer errors if ( response && response . body ) { error . name = 'GitHubError' ; error . message = ` ${ response . body . message } ( ${ response . statusCode } status code)` ; } // Rate limit for errors if ( response ) { error . rateLimit = getRateLimit ( response . headers ); } throw error ; } })(); } ] ... \u86cb\u7cd5\u4e0a\u7684\u7cd6\u971c: User-Agent \u5934\u3002 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 const packageJson = { name : 'gh-got' , version : '12.0.0' }; const instance = got . extend ({ ... headers : { accept : 'application/vnd.github.v3+json' , 'user-agent' : ` ${ packageJson . name } / ${ packageJson . version } ` }, ... }); \u54c7\u3002\u5c31\u662f\u8fd9\u6837\u5417\uff1f \u00b6 Yup. View the full source code here . Here's an example of how to use it: 1 2 3 4 5 6 7 import ghGot from \"gh-got\" ; const response = await ghGot ( \"users/sindresorhus\" ); const creationDate = new Date ( response . created_at ); console . log ( `Sindre's GitHub profile was created on ${ creationDate . toGMTString () } ` ); // => Sindre's GitHub profile was created on Sun, 20 Dec 2009 22:57:02 GMT \u5206\u9875 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 import ghGot from \"gh-got\" ; const countLimit = 50 ; const pagination = ghGot . paginate ( \"repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); } That's... astonishing! We don't have to implement pagination on our own. Got handles it all. \u5728\u6700\u540e \u00b6 \u60a8\u77e5\u9053\u53ef\u4ee5\u5c06\u8bb8\u591a\u5b9e\u4f8b\u6df7\u5408\u5230\u4e00\u4e2a\u66f4\u5927\u3001\u66f4\u5f3a\u5927\u7684\u5b9e\u4f8b\u4e2d\u5417?\u67e5\u770b \u9ad8\u7ea7\u521b\u4f5c \u6307\u5357\u3002","title":"\u63d2\u4ef6"},{"location":"lets-make-a-plugin/#_1","text":"\u53e6\u4e00\u4e2a\u5173\u4e8e\u5982\u4f55\u50cf\u8001\u677f\u4e00\u6837\u4f7f\u7528 Got \u7684\u4f8b\u5b50 \u597d\u4e86\uff0c\u4f60\u4eec\u5df2\u7ecf\u5b66\u4e86\u4e00\u4e9b\u57fa\u7840\u77e5\u8bc6\u3002\u592a\u597d\u4e86! When it comes to advanced usage, custom instances are really helpful. For example, take a look at gh-got . It looks pretty complicated, but... it's simple and extremely useful. Before we start, we need to find the GitHub API docs . Let's write down the most important information: The root endpoint is https://api.github.com/ . We will use version 3 of the API.\\ The Accept header needs to be set to application/vnd.github.v3+json . The body is in a JSON format. We will use OAuth2 for authorization. We may receive 400 Bad Request or 422 Unprocessable Entity .\\ The body contains detailed information about the error. Pagination? Yeah! Supported natively by Got. Rate limiting. These headers are interesting: X-RateLimit-Limit X-RateLimit-Remaining X-RateLimit-Reset Also X-GitHub-Request-Id may be useful for debugging. The User-Agent header is required. When we have all the necessary info, we can start mixing","title":"\u63d2\u4ef6"},{"location":"lets-make-a-plugin/#_2","text":"Not much to do here. Just extend an instance and provide the prefixUrl option: 1 2 3 4 5 6 7 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , }); export default instance ;","title":"\u6839\u7aef\u70b9"},{"location":"lets-make-a-plugin/#v3-api","text":"GitHub needs to know which API version we are using. We'll use the Accept header for that: 1 2 3 4 5 6 7 8 9 10 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, }); export default instance ;","title":"v3 API"},{"location":"lets-make-a-plugin/#json-body","text":"We'll use options.responseType : 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , }); export default instance ;","title":"JSON body"},{"location":"lets-make-a-plugin/#_3","text":"It's common to set some environment variables, for example, GITHUB_TOKEN . You can modify the tokens in all your apps easily, right? Cool. What about... we want to provide a unique token for each app. Then we will need to create a new option - it will default to the environment variable, but you can easily override it. Got performs option validation and doesn't know that token is a wanted option so it will throw. We can handle it inside an init hook and save it in options.context . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , context : { token : process . env . GITHUB_TOKEN , }, hooks : { init : [ ( raw , options ) => { if ( \"token\" in raw ) { options . context . token = raw . token ; delete raw . token ; } }, ], }, }); export default instance ; For the rest we will use a handler. We could use hooks, but this way it will be more readable. Having beforeRequest , beforeError and afterResponse hooks for just a few lines of code would complicate things unnecessarily. Tip: It's a good practice to use hooks when your plugin gets complicated. Try not to overload the handler function, but don't abuse hooks either. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import got from \"got\" ; const instance = got . extend ({ prefixUrl : \"https://api.github.com\" , headers : { accept : \"application/vnd.github.v3+json\" , }, responseType : \"json\" , context : { token : process . env . GITHUB_TOKEN , }, hooks : { init : [ ( raw , options ) => { if ( \"token\" in raw ) { options . context . token = raw . token ; delete raw . token ; } }, ], }, handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } return next ( options ); }, ], }); export default instance ;","title":"\u6388\u6743"},{"location":"lets-make-a-plugin/#_4","text":"We should name our errors, just to know if the error is from the API response. Superb errors, here we come! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ... handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } // Don't touch streams if ( options . isStream ) { return next ( options ); } // Magic begins return ( async () => { try { const response = await next ( options ); return response ; } catch ( error ) { const { response } = error ; // Nicer errors if ( response && response . body ) { error . name = 'GitHubError' ; error . message = ` ${ response . body . message } ( ${ response . statusCode } status code)` ; } throw error ; } })(); } ] ... Note that by providing our own errors in handlers, we don't alter the ones in beforeError hooks.\\ The conversion is the last thing here.","title":"\u9519\u8bef"},{"location":"lets-make-a-plugin/#_5","text":"Umm... response.headers['x-ratelimit-remaining'] doesn't look good. What about response.rateLimit.limit instead?\\ Yeah, definitely. Since response.headers is an object, we can easily parse these: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const getRateLimit = ( headers ) => ({ limit : Number . parseInt ( headers [ \"x-ratelimit-limit\" ], 10 ), remaining : Number . parseInt ( headers [ \"x-ratelimit-remaining\" ], 10 ), reset : new Date ( Number . parseInt ( headers [ \"x-ratelimit-reset\" ], 10 ) * 1000 ), }); getRateLimit ({ \"x-ratelimit-limit\" : \"60\" , \"x-ratelimit-remaining\" : \"55\" , \"x-ratelimit-reset\" : \"1562852139\" , }); // => { // limit: 60, // remaining: 55, // reset: 2019-07-11T13:35:39.000Z // } Let's integrate it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const getRateLimit = ( headers ) => ({ limit : Number . parseInt ( headers [ 'x-ratelimit-limit' ], 10 ), remaining : Number . parseInt ( headers [ 'x-ratelimit-remaining' ], 10 ), reset : new Date ( Number . parseInt ( headers [ 'x-ratelimit-reset' ], 10 ) * 1000 ) }); ... handlers : [ ( options , next ) => { // Authorization const { token } = options . context ; if ( token && ! options . headers . authorization ) { options . headers . authorization = `token ${ token } ` ; } // Don't touch streams if ( options . isStream ) { return next ( options ); } // Magic begins return ( async () => { try { const response = await next ( options ); // Rate limit for the Response object response . rateLimit = getRateLimit ( response . headers ); return response ; } catch ( error ) { const { response } = error ; // Nicer errors if ( response && response . body ) { error . name = 'GitHubError' ; error . message = ` ${ response . body . message } ( ${ response . statusCode } status code)` ; } // Rate limit for errors if ( response ) { error . rateLimit = getRateLimit ( response . headers ); } throw error ; } })(); } ] ...","title":"\u901f\u5ea6\u9650\u5236"},{"location":"lets-make-a-plugin/#user-agent","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 const packageJson = { name : 'gh-got' , version : '12.0.0' }; const instance = got . extend ({ ... headers : { accept : 'application/vnd.github.v3+json' , 'user-agent' : ` ${ packageJson . name } / ${ packageJson . version } ` }, ... });","title":"\u86cb\u7cd5\u4e0a\u7684\u7cd6\u971c: User-Agent\u5934\u3002"},{"location":"lets-make-a-plugin/#_6","text":"Yup. View the full source code here . Here's an example of how to use it: 1 2 3 4 5 6 7 import ghGot from \"gh-got\" ; const response = await ghGot ( \"users/sindresorhus\" ); const creationDate = new Date ( response . created_at ); console . log ( `Sindre's GitHub profile was created on ${ creationDate . toGMTString () } ` ); // => Sindre's GitHub profile was created on Sun, 20 Dec 2009 22:57:02 GMT","title":"\u54c7\u3002\u5c31\u662f\u8fd9\u6837\u5417\uff1f"},{"location":"lets-make-a-plugin/#_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 import ghGot from \"gh-got\" ; const countLimit = 50 ; const pagination = ghGot . paginate ( \"repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); } That's... astonishing! We don't have to implement pagination on our own. Got handles it all.","title":"\u5206\u9875"},{"location":"lets-make-a-plugin/#_8","text":"\u60a8\u77e5\u9053\u53ef\u4ee5\u5c06\u8bb8\u591a\u5b9e\u4f8b\u6df7\u5408\u5230\u4e00\u4e2a\u66f4\u5927\u3001\u66f4\u5f3a\u5927\u7684\u5b9e\u4f8b\u4e2d\u5417?\u67e5\u770b \u9ad8\u7ea7\u521b\u4f5c \u6307\u5357\u3002","title":"\u5728\u6700\u540e"},{"location":"quick-start/","text":"\u5feb\u901f\u5165\u95e8\u6307\u5357 \u00b6 \u83b7\u5f97\u548c\u53d1\u5e03\u6570\u636e \u00b6 \u6700\u7b80\u5355\u7684 GET \u8bf7\u6c42: 1 2 3 4 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const response = await got ( url ); \u8c03\u7528\u8fd4\u56de Promise< Response > \u3002 \u5982\u679c\u4e3b\u4f53\u5305\u542b JSON\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u68c0\u7d22: 1 2 3 4 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const data = await got ( url ). json (); \u7c7b\u4f3c\u7684 got.text \u65b9\u6cd5\u8fd4\u56de\u7eaf\u6587\u672c\u3002 \u6240\u6709 got \u65b9\u6cd5\u90fd\u63a5\u53d7\u4e00\u4e2a options \u5bf9\u8c61\u6765\u4f20\u9012\u989d\u5916\u7684\u914d\u7f6e\uff0c\u6bd4\u5982\u5934\u4fe1\u606f: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { headers : { \"Custom-Header\" : \"Quick start\" , }, timeout : { send : 3500 , }, }; const data = await got ( url , options ). json (); \u4e00\u4e2a POST \u8bf7\u6c42\u975e\u5e38\u7c7b\u4f3c: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { json : { documentName : \"Quick Start\" , }, }; const data = await got . post ( url , options ); \u8bf7\u6c42\u4f53\u5728 options \u5bf9\u8c61\u4e2d\u4f20\u9012\u3002 json \u5c5e\u6027\u5c06\u81ea\u52a8\u76f8\u5e94\u5730\u8bbe\u7f6e\u6807\u9898\u3002 \u53ef\u4ee5\u50cf\u4e0a\u9762\u4e00\u6837\u6dfb\u52a0\u81ea\u5b9a\u4e49\u6807\u5934\u3002 \u4f7f\u7528\u6d41 \u00b6 Stream API \u5141\u8bb8\u5229\u7528 Node.js Streams \u529f\u80fd: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import fs from \"node:fs\" ; import { pipeline } from \"node:stream/promises\" ; import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { json : { documentName : \"Quick Start\" , }, }; const gotStream = got . stream . post ( url , options ); const outStream = fs . createWriteStream ( \"anything.json\" ); try { await pipeline ( gotStream , outStream ); } catch ( error ) { console . error ( error ); } \u9009\u9879 \u00b6 \u9009\u9879\u53ef\u4ee5\u5728\u5ba2\u6237\u7aef\u7ea7\u522b\u8bbe\u7f6e\uff0c\u5e76\u5728\u540e\u7eed\u67e5\u8be2\u4e2d\u91cd\u7528: 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const options = { prefixUrl : \"https://httpbin.org\" , headers : { Authorization : getTokenFromVault (), }, }; const client = got . extend ( options ); export default client ; \u4e00\u4e9b\u5e38\u89c1\u7684\u9009\u9879\u662f: searchParams : \u67e5\u8be2\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002 prefixUrl : \u524d\u7f6e\u67e5\u8be2\u8def\u5f84\u3002\u8def\u5f84\u5fc5\u987b\u76f8\u5bf9\u4e8e\u524d\u7f00\uff0c\u5373\u4e0d\u80fd\u4ee5 / \u5f00\u5934\u3002 method : HTTP \u65b9\u6cd5\u540d\u3002 headers : \u67e5\u8be2\u5934\u3002 json : JSON body. form : \u4e00\u4e2a\u8868\u5355\u67e5\u8be2\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002 \u6709\u5173\u5176\u4ed6 \u9009\u9879 \uff0c\u8bf7\u53c2\u9605\u6587\u6863. \u9519\u8bef \u00b6 Promise \u548c Stream api \u90fd\u4f7f\u7528\u5143\u6570\u636e\u629b\u51fa\u9519\u8bef\u3002 1 2 3 4 5 6 7 import got from \"got\" ; try { const data = await got . get ( \"https://httpbin.org/status/404\" ); } catch ( error ) { console . error ( error . response . statusCode ); } 1 2 3 4 5 import got from \"got\" ; const stream = got . stream . get ( \"https://httpbin.org/status/404\" ). once ( \"error\" , ( error ) => { console . error ( error . response . statusCode ); }); \u6742\u9879 \u00b6 HTTP \u65b9\u6cd5\u540d\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u9009\u9879\u7ed9\u51fa\uff0c\u5f53\u5b83\u53ea\u5728\u8fd0\u884c\u65f6\u624d\u77e5\u9053\u65f6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5f88\u65b9\u4fbf: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const method = \"POST\" ; const options = { method , json : { documentName : \"Quick Start\" , }, }; const data = await got ( url , options ); \u5bf9\u4e8e\u5927\u591a\u6570\u5e94\u7528\u7a0b\u5e8f\uff0cHTTP \u5ba2\u6237\u7aef\u53ea\u505a GET \u548c POST \u67e5\u8be2( PUT \uff0c PATCH \u6216 DELETE \u65b9\u6cd5\u5de5\u4f5c\u7c7b\u4f3c)\u3002 \u4e0b\u9762\u7684\u90e8\u5206\u5c06\u63d0\u4f9b\u4e00\u4e9b\u66f4\u9ad8\u7ea7\u7684\u7528\u6cd5\u3002 \u8d85\u65f6 \u00b6 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8bf7\u6c42\u6ca1\u6709\u8d85\u65f6\u3002\u4e00\u4e2a\u597d\u7684\u505a\u6cd5\u662f\u8bbe\u7f6e\u4e00\u4e2a: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const options = { timeout : { request : 10000 , }, }; const client = got . extend ( options ); export default client ; \u4e0a\u9762\u4e3a\u5bfc\u51fa\u7684 client \u53d1\u51fa\u7684\u6240\u6709\u8bf7\u6c42\u8bbe\u7f6e\u4e86 10000 \u6beb\u79d2\u7684\u5168\u5c40\u8d85\u65f6\u3002 \u4e0e\u6240\u6709\u9009\u9879\u4e00\u6837\uff0c\u8d85\u65f6\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\u5728\u8bf7\u6c42\u7ea7\u522b\u3002 \u53c2\u89c1 timeout \u9009\u9879 \u3002 \u91cd\u8bd5 \u00b6 \u5931\u8d25\u7684\u8bf7\u6c42\u5c06\u91cd\u8bd5\u4e24\u6b21\u3002 \u91cd\u8bd5\u7b56\u7565\u53ef\u4ee5\u901a\u8fc7 retry \u9009\u9879\u5bf9\u8c61\u8fdb\u884c\u8c03\u4f18\u3002 1 2 3 4 5 6 7 8 import got from \"got\" ; const options = { retry : { limit : 5 , errorCodes : [ \"ETIMEDOUT\" ], }, }; stream \u7684\u91cd\u8bd5\u5c31\u6709\u70b9\u68d8\u624b\u4e86 stream.on('retry', \u2026) . \u94a9\u5b50 \u00b6 \u94a9\u5b50\u662f\u5728\u4e00\u4e9b\u8bf7\u6c42\u4e8b\u4ef6\u4e0a\u8c03\u7528\u7684\u81ea\u5b9a\u4e49\u51fd\u6570: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; const logRetry = ( error , retryCount ) => { console . error ( `Retrying after error ${ error . code } , retry #: ${ retryCount } ` ); }; const options = { hooks : { beforeRetry : [ logRetry ], }, }; const client = got . extend ( options ); export default client ; \u6ce8\u610f\uff0c\u94a9\u5b50\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u7ed9\u51fa , \u56e0\u6b64\u53ef\u4ee5\u7ed9\u51fa\u591a\u4e2a\u94a9\u5b50\u3002\u53c2\u89c1\u6587\u6863\u4e86\u89e3\u5176\u4ed6\u53ef\u80fd\u7684 \u94a9\u5b50 . \u8d70\u5f97\u66f4\u8fdc \u00b6 \u5728 documentation \u548c tips \u4e2d\u8fd8\u6709\u5f88\u591a\u9700\u8981\u53d1\u73b0\u7684\u5730\u65b9\u3002 \u5176\u4e2d\uff0c Got \u53ef\u4ee5\u5904\u7406 cookies \uff0c pagination \uff0c cache \u3002 \u5728\u5b9e\u73b0 Got \u5df2\u7ecf\u5b8c\u6210\u7684\u64cd\u4f5c\u4e4b\u524d\uff0c\u8bf7\u9605\u8bfb\u6587\u6863\u3002","title":"\u5feb\u901f\u5165\u95e8\u6307\u5357"},{"location":"quick-start/#_1","text":"","title":"\u5feb\u901f\u5165\u95e8\u6307\u5357"},{"location":"quick-start/#_2","text":"\u6700\u7b80\u5355\u7684 GET \u8bf7\u6c42: 1 2 3 4 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const response = await got ( url ); \u8c03\u7528\u8fd4\u56de Promise< Response > \u3002 \u5982\u679c\u4e3b\u4f53\u5305\u542b JSON\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u68c0\u7d22: 1 2 3 4 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const data = await got ( url ). json (); \u7c7b\u4f3c\u7684 got.text \u65b9\u6cd5\u8fd4\u56de\u7eaf\u6587\u672c\u3002 \u6240\u6709 got \u65b9\u6cd5\u90fd\u63a5\u53d7\u4e00\u4e2a options \u5bf9\u8c61\u6765\u4f20\u9012\u989d\u5916\u7684\u914d\u7f6e\uff0c\u6bd4\u5982\u5934\u4fe1\u606f: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { headers : { \"Custom-Header\" : \"Quick start\" , }, timeout : { send : 3500 , }, }; const data = await got ( url , options ). json (); \u4e00\u4e2a POST \u8bf7\u6c42\u975e\u5e38\u7c7b\u4f3c: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { json : { documentName : \"Quick Start\" , }, }; const data = await got . post ( url , options ); \u8bf7\u6c42\u4f53\u5728 options \u5bf9\u8c61\u4e2d\u4f20\u9012\u3002 json \u5c5e\u6027\u5c06\u81ea\u52a8\u76f8\u5e94\u5730\u8bbe\u7f6e\u6807\u9898\u3002 \u53ef\u4ee5\u50cf\u4e0a\u9762\u4e00\u6837\u6dfb\u52a0\u81ea\u5b9a\u4e49\u6807\u5934\u3002","title":"\u83b7\u5f97\u548c\u53d1\u5e03\u6570\u636e"},{"location":"quick-start/#_3","text":"Stream API \u5141\u8bb8\u5229\u7528 Node.js Streams \u529f\u80fd: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import fs from \"node:fs\" ; import { pipeline } from \"node:stream/promises\" ; import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const options = { json : { documentName : \"Quick Start\" , }, }; const gotStream = got . stream . post ( url , options ); const outStream = fs . createWriteStream ( \"anything.json\" ); try { await pipeline ( gotStream , outStream ); } catch ( error ) { console . error ( error ); }","title":"\u4f7f\u7528\u6d41"},{"location":"quick-start/#_4","text":"\u9009\u9879\u53ef\u4ee5\u5728\u5ba2\u6237\u7aef\u7ea7\u522b\u8bbe\u7f6e\uff0c\u5e76\u5728\u540e\u7eed\u67e5\u8be2\u4e2d\u91cd\u7528: 1 2 3 4 5 6 7 8 9 10 11 12 import got from \"got\" ; const options = { prefixUrl : \"https://httpbin.org\" , headers : { Authorization : getTokenFromVault (), }, }; const client = got . extend ( options ); export default client ; \u4e00\u4e9b\u5e38\u89c1\u7684\u9009\u9879\u662f: searchParams : \u67e5\u8be2\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002 prefixUrl : \u524d\u7f6e\u67e5\u8be2\u8def\u5f84\u3002\u8def\u5f84\u5fc5\u987b\u76f8\u5bf9\u4e8e\u524d\u7f00\uff0c\u5373\u4e0d\u80fd\u4ee5 / \u5f00\u5934\u3002 method : HTTP \u65b9\u6cd5\u540d\u3002 headers : \u67e5\u8be2\u5934\u3002 json : JSON body. form : \u4e00\u4e2a\u8868\u5355\u67e5\u8be2\u5b57\u7b26\u4e32\u5bf9\u8c61\u3002 \u6709\u5173\u5176\u4ed6 \u9009\u9879 \uff0c\u8bf7\u53c2\u9605\u6587\u6863.","title":"\u9009\u9879"},{"location":"quick-start/#_5","text":"Promise \u548c Stream api \u90fd\u4f7f\u7528\u5143\u6570\u636e\u629b\u51fa\u9519\u8bef\u3002 1 2 3 4 5 6 7 import got from \"got\" ; try { const data = await got . get ( \"https://httpbin.org/status/404\" ); } catch ( error ) { console . error ( error . response . statusCode ); } 1 2 3 4 5 import got from \"got\" ; const stream = got . stream . get ( \"https://httpbin.org/status/404\" ). once ( \"error\" , ( error ) => { console . error ( error . response . statusCode ); });","title":"\u9519\u8bef"},{"location":"quick-start/#_6","text":"HTTP \u65b9\u6cd5\u540d\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u4e2a\u9009\u9879\u7ed9\u51fa\uff0c\u5f53\u5b83\u53ea\u5728\u8fd0\u884c\u65f6\u624d\u77e5\u9053\u65f6\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5f88\u65b9\u4fbf: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import got from \"got\" ; const url = \"https://httpbin.org/anything\" ; const method = \"POST\" ; const options = { method , json : { documentName : \"Quick Start\" , }, }; const data = await got ( url , options ); \u5bf9\u4e8e\u5927\u591a\u6570\u5e94\u7528\u7a0b\u5e8f\uff0cHTTP \u5ba2\u6237\u7aef\u53ea\u505a GET \u548c POST \u67e5\u8be2( PUT \uff0c PATCH \u6216 DELETE \u65b9\u6cd5\u5de5\u4f5c\u7c7b\u4f3c)\u3002 \u4e0b\u9762\u7684\u90e8\u5206\u5c06\u63d0\u4f9b\u4e00\u4e9b\u66f4\u9ad8\u7ea7\u7684\u7528\u6cd5\u3002","title":"\u6742\u9879"},{"location":"quick-start/#_7","text":"\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8bf7\u6c42\u6ca1\u6709\u8d85\u65f6\u3002\u4e00\u4e2a\u597d\u7684\u505a\u6cd5\u662f\u8bbe\u7f6e\u4e00\u4e2a: 1 2 3 4 5 6 7 8 9 10 11 import got from \"got\" ; const options = { timeout : { request : 10000 , }, }; const client = got . extend ( options ); export default client ; \u4e0a\u9762\u4e3a\u5bfc\u51fa\u7684 client \u53d1\u51fa\u7684\u6240\u6709\u8bf7\u6c42\u8bbe\u7f6e\u4e86 10000 \u6beb\u79d2\u7684\u5168\u5c40\u8d85\u65f6\u3002 \u4e0e\u6240\u6709\u9009\u9879\u4e00\u6837\uff0c\u8d85\u65f6\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\u5728\u8bf7\u6c42\u7ea7\u522b\u3002 \u53c2\u89c1 timeout \u9009\u9879 \u3002","title":"\u8d85\u65f6"},{"location":"quick-start/#_8","text":"\u5931\u8d25\u7684\u8bf7\u6c42\u5c06\u91cd\u8bd5\u4e24\u6b21\u3002 \u91cd\u8bd5\u7b56\u7565\u53ef\u4ee5\u901a\u8fc7 retry \u9009\u9879\u5bf9\u8c61\u8fdb\u884c\u8c03\u4f18\u3002 1 2 3 4 5 6 7 8 import got from \"got\" ; const options = { retry : { limit : 5 , errorCodes : [ \"ETIMEDOUT\" ], }, }; stream \u7684\u91cd\u8bd5\u5c31\u6709\u70b9\u68d8\u624b\u4e86 stream.on('retry', \u2026) .","title":"\u91cd\u8bd5"},{"location":"quick-start/#_9","text":"\u94a9\u5b50\u662f\u5728\u4e00\u4e9b\u8bf7\u6c42\u4e8b\u4ef6\u4e0a\u8c03\u7528\u7684\u81ea\u5b9a\u4e49\u51fd\u6570: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; const logRetry = ( error , retryCount ) => { console . error ( `Retrying after error ${ error . code } , retry #: ${ retryCount } ` ); }; const options = { hooks : { beforeRetry : [ logRetry ], }, }; const client = got . extend ( options ); export default client ; \u6ce8\u610f\uff0c\u94a9\u5b50\u4ee5\u6570\u7ec4\u7684\u5f62\u5f0f\u7ed9\u51fa , \u56e0\u6b64\u53ef\u4ee5\u7ed9\u51fa\u591a\u4e2a\u94a9\u5b50\u3002\u53c2\u89c1\u6587\u6863\u4e86\u89e3\u5176\u4ed6\u53ef\u80fd\u7684 \u94a9\u5b50 .","title":"\u94a9\u5b50"},{"location":"quick-start/#_10","text":"\u5728 documentation \u548c tips \u4e2d\u8fd8\u6709\u5f88\u591a\u9700\u8981\u53d1\u73b0\u7684\u5730\u65b9\u3002 \u5176\u4e2d\uff0c Got \u53ef\u4ee5\u5904\u7406 cookies \uff0c pagination \uff0c cache \u3002 \u5728\u5b9e\u73b0 Got \u5df2\u7ecf\u5b8c\u6210\u7684\u64cd\u4f5c\u4e4b\u524d\uff0c\u8bf7\u9605\u8bfb\u6587\u6863\u3002","title":"\u8d70\u5f97\u66f4\u8fdc"},{"location":"tags/","text":"\u6807\u7b7e \u00b6","title":"\u6807\u7b7e"},{"location":"tags/#_1","text":"","title":"\u6807\u7b7e"},{"location":"tips/","text":"\u6280\u5de7 \u00b6 Timeout \u00b6 Each request can have a maximum allowed time to run.\\ In order to use this, specify the request timeout option. 1 2 3 4 5 6 7 import got from \"got\" ; const body = await got ( \"https://httpbin.org/anything\" , { timeout : { request : 30000 , }, }); For more specific timeouts, visit the Timeout API . Retries \u00b6 By default, Got makes a new retry on a failed request if possible. It is possible to disable this feature entirely by setting the amount of maximum allowed retries to 0 . 1 2 3 4 5 6 7 import got from \"got\" ; const noRetryGot = got . extend ({ retry : { limit : 0 , }, }); In order to specify retriable errors, use the Retry API . Cookies \u00b6 Got supports cookies out of box. There is no need to parse them manually.\\ In order to use cookies, pass a CookieJar instance from the tough-cookie package. 1 2 3 4 5 6 7 import got from \"got\" ; import { CookieJar } from \"tough-cookie\" ; const cookieJar = new CookieJar (); await cookieJar . setCookie ( \"foo=bar\" , \"https://httpbin.org\" ); await got ( \"https://httpbin.org/anything\" , { cookieJar }); AWS \u00b6 Requests to AWS services need to have their headers signed.\\ This can be accomplished by using the got4aws package. This is an example for querying an API Gateway with a signed request. 1 2 3 4 5 6 7 import got4aws from \"got4aws\" ; const got = got4aws (); const response = await got ( \"https://<api-id>.execute-api.<api-region>.amazonaws.com/<stage>/endpoint/path\" , { // \u2026 }); Pagination \u00b6 When working with large datasets, it's very efficient to use pagination.\\ By default, Got uses the Link header to retrieve the next page.\\ However, this behavior can be customized, see the Pagination API . 1 2 3 4 5 6 7 8 9 10 11 const countLimit = 50 ; const pagination = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); } UNIX Domain Sockets \u00b6 See the enableUnixSockets option . Testing \u00b6 Got uses the native http module, which depends on the native net module.\\ This means there are two possible ways to test: Use a mocking library like nock , Create a server. The first approach should cover all common use cases.\\ Bear in mind that it overrides the native http module, so bugs may occur due to the differences. The most solid way is to create a server.\\ There may be cases where nock won't be sufficient or lacks functionality. Nock \u00b6 By default nock mocks only one request.\\ Got will retry on failed requests by default, causing a No match for request ... error.\\ The solution is to either disable retrying (set options.retry.limit to 0 ) or call .persist() on the mocked request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; import nock from \"nock\" ; const scope = nock ( \"https://sindresorhus.com\" ). get ( \"/\" ). reply ( 500 , \"Internal server error\" ). persist (); try { await got ( \"https://sindresorhus.com\" ); } catch ( error ) { console . log ( error . response . body ); //=> 'Internal server error' console . log ( error . response . retryCount ); //=> 2 } scope . persist ( false ); Proxying \u00b6 Note: The popular tunnel package is unmaintained. Use at your own risk. The proxy-agent family doesn't follow newest Node.js features and lacks support. Although there isn't a perfect, bug-free package, Apify 's solution is a modern one.\\ See got-scraping/src/agent/h1-proxy-agent.ts . It has the same API as hpagent . hpagent is a modern package as well. In contrast to tunnel , it allows keeping the internal sockets alive to be reused. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; import { HttpsProxyAgent } from \"hpagent\" ; await got ( \"https://sindresorhus.com\" , { agent : { https : new HttpsProxyAgent ({ keepAlive : true , keepAliveMsecs : 1000 , maxSockets : 256 , maxFreeSockets : 256 , scheduling : \"lifo\" , proxy : \"https://localhost:8080\" , }), }, }); Alternatively, use global-agent to configure a global proxy for all HTTP/HTTPS traffic in your program. If you're using HTTP/2, the http2-wrapper package provides proxy support out-of-box.\\ Learn more. Retry without an agent \u00b6 If you're using proxies, you may run into connection issues.\\ One way out is to disable proxies when retrying. The solution for the Stream API looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import https from \"https\" ; import fs from \"fs\" ; import got from \"got\" ; class MyAgent extends https . Agent { createConnection ( port , options , callback ) { console . log ( `Connecting with MyAgent` ); return https . Agent . prototype . createConnection . call ( this , port , options , callback ); } } const proxy = new MyAgent (); let writeStream ; const fn = ( retryStream ) => { const options = { agent : { https : proxy , }, }; const stream = retryStream ?? got . stream ( \"https://example.com\" , options ); if ( writeStream ) { writeStream . destroy (); } writeStream = fs . createWriteStream ( \"example-com.html\" ); stream . pipe ( writeStream ); stream . once ( \"retry\" , ( retryCount , error , createRetryStream ) => { fn ( createRetryStream ({ agent : { http : undefined , https : undefined , http2 : undefined , }, }) ); }); }; fn (); h2c \u00b6 There is no direct h2c support. However, you can provide a h2session option in a beforeRequest hook. See an example . Uppercase headers \u00b6 Got always normalizes the headers, therefore passing an Uppercase-Header will transform it into uppercase-header . To fix this, you need to pass a wrapped agent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WrappedAgent { constructor ( agent ) { this . agent = agent ; } addRequest ( request , options ) { return this . agent . addRequest ( request , options ); } get keepAlive () { return this . agent . keepAlive ; } get maxSockets () { return this . agent . maxSockets ; } get options () { return this . agent . options ; } get defaultPort () { return this . agent . defaultPort ; } get protocol () { return this . agent . protocol ; } } class TransformHeadersAgent extends WrappedAgent { addRequest ( request , options ) { const headers = request . getHeaderNames (); for ( const header of headers ) { request . setHeader ( this . transformHeader ( header ), request . getHeader ( header )); } return super . addRequest ( request , options ); } transformHeader ( header ) { return header . split ( \"-\" ) . map (( part ) => { return part [ 0 ]. toUpperCase () + part . slice ( 1 ); }) . join ( \"-\" ); } } const agent = new http . Agent ({ keepAlive : true , }); const wrappedAgent = new TransformHeadersAgent ( agent ); See an example . Custom options \u00b6 Got v12 throws when an option does not exist. Therefore passing a top-level option such as: 1 2 3 4 5 import got from \"got\" ; await got ( \"https://example.com\" , { foo : \"bar\" , }); will throw. To prevent this, you need read the option in an init hook: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import got from \"got\" ; const convertFoo = got . extend ({ hooks : { init : [ ( rawOptions , options ) => { if ( \"foo\" in rawOptions ) { options . context . foo = rawOptions . foo ; delete rawOptions . foo ; } }, ], }, }); const instance = got . extend ( convertFoo , { hooks : { beforeRequest : [ ( options ) => { options . headers . foo = options . context . foo ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { foo : \"bar\" }). json (); console . log ( headers . Foo ); //=> 'bar' Eventually, you may want to create a catch-all instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import got from \"got\" ; const catchAllOptions = got . extend ({ hooks : { init : [ ( raw , options ) => { for ( const key in raw ) { if ( ! ( key in options )) { options . context [ key ] = raw [ key ]; delete raw [ key ]; } } }, ], }, }); const instance = got . extend ( catchAllOptions , { hooks : { beforeRequest : [ ( options ) => { // All custom options will be visible under `options.context` options . headers . foo = options . context . foo ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { foo : \"bar\" }). json (); console . log ( headers . Foo ); //=> 'bar' Note: It's a good practice to perform the validation inside the init hook. You can safely throw when an option is unknown! Internally, Got uses the @sindresorhus/is package. Electron net module is not supported \u00b6 Note: Got v12 and later is an ESM package, but Electron does not yet support ESM. So you need to use Got v11. Got doesn't support the electron.net module. It's missing crucial APIs that are available in Node.js.\\ While Got used to support electron.net , it got very unstable and caused many errors. However, you can use IPC communication to get the Response object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Main process const got = require ( \"got\" ); const instance = got . extend ({ // ... }); ipcMain . handle ( \"got\" , async ( event , ... args ) => { const { statusCode , headers , body } = await instance (... args ); return { statusCode , headers , body }; }); // Renderer process async () => { const { statusCode , headers , body } = await ipcRenderer . invoke ( \"got\" , \"https://httpbin.org/anything\" ); // ... };","title":"\u6280\u5de7"},{"location":"tips/#_1","text":"","title":"\u6280\u5de7"},{"location":"tips/#timeout","text":"Each request can have a maximum allowed time to run.\\ In order to use this, specify the request timeout option. 1 2 3 4 5 6 7 import got from \"got\" ; const body = await got ( \"https://httpbin.org/anything\" , { timeout : { request : 30000 , }, }); For more specific timeouts, visit the Timeout API .","title":"Timeout"},{"location":"tips/#retries","text":"By default, Got makes a new retry on a failed request if possible. It is possible to disable this feature entirely by setting the amount of maximum allowed retries to 0 . 1 2 3 4 5 6 7 import got from \"got\" ; const noRetryGot = got . extend ({ retry : { limit : 0 , }, }); In order to specify retriable errors, use the Retry API .","title":"Retries"},{"location":"tips/#cookies","text":"Got supports cookies out of box. There is no need to parse them manually.\\ In order to use cookies, pass a CookieJar instance from the tough-cookie package. 1 2 3 4 5 6 7 import got from \"got\" ; import { CookieJar } from \"tough-cookie\" ; const cookieJar = new CookieJar (); await cookieJar . setCookie ( \"foo=bar\" , \"https://httpbin.org\" ); await got ( \"https://httpbin.org/anything\" , { cookieJar });","title":"Cookies"},{"location":"tips/#aws","text":"Requests to AWS services need to have their headers signed.\\ This can be accomplished by using the got4aws package. This is an example for querying an API Gateway with a signed request. 1 2 3 4 5 6 7 import got4aws from \"got4aws\" ; const got = got4aws (); const response = await got ( \"https://<api-id>.execute-api.<api-region>.amazonaws.com/<stage>/endpoint/path\" , { // \u2026 });","title":"AWS"},{"location":"tips/#pagination","text":"When working with large datasets, it's very efficient to use pagination.\\ By default, Got uses the Link header to retrieve the next page.\\ However, this behavior can be customized, see the Pagination API . 1 2 3 4 5 6 7 8 9 10 11 const countLimit = 50 ; const pagination = got . paginate ( \"https://api.github.com/repos/sindresorhus/got/commits\" , { pagination : { countLimit }, }); console . log ( `Printing latest ${ countLimit } Got commits (newest to oldest):` ); for await ( const commitData of pagination ) { console . log ( commitData . commit . message ); }","title":"Pagination"},{"location":"tips/#unix-domain-sockets","text":"See the enableUnixSockets option .","title":"UNIX Domain Sockets"},{"location":"tips/#testing","text":"Got uses the native http module, which depends on the native net module.\\ This means there are two possible ways to test: Use a mocking library like nock , Create a server. The first approach should cover all common use cases.\\ Bear in mind that it overrides the native http module, so bugs may occur due to the differences. The most solid way is to create a server.\\ There may be cases where nock won't be sufficient or lacks functionality.","title":"Testing"},{"location":"tips/#nock","text":"By default nock mocks only one request.\\ Got will retry on failed requests by default, causing a No match for request ... error.\\ The solution is to either disable retrying (set options.retry.limit to 0 ) or call .persist() on the mocked request. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import got from \"got\" ; import nock from \"nock\" ; const scope = nock ( \"https://sindresorhus.com\" ). get ( \"/\" ). reply ( 500 , \"Internal server error\" ). persist (); try { await got ( \"https://sindresorhus.com\" ); } catch ( error ) { console . log ( error . response . body ); //=> 'Internal server error' console . log ( error . response . retryCount ); //=> 2 } scope . persist ( false );","title":"Nock"},{"location":"tips/#proxying","text":"Note: The popular tunnel package is unmaintained. Use at your own risk. The proxy-agent family doesn't follow newest Node.js features and lacks support. Although there isn't a perfect, bug-free package, Apify 's solution is a modern one.\\ See got-scraping/src/agent/h1-proxy-agent.ts . It has the same API as hpagent . hpagent is a modern package as well. In contrast to tunnel , it allows keeping the internal sockets alive to be reused. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import got from \"got\" ; import { HttpsProxyAgent } from \"hpagent\" ; await got ( \"https://sindresorhus.com\" , { agent : { https : new HttpsProxyAgent ({ keepAlive : true , keepAliveMsecs : 1000 , maxSockets : 256 , maxFreeSockets : 256 , scheduling : \"lifo\" , proxy : \"https://localhost:8080\" , }), }, }); Alternatively, use global-agent to configure a global proxy for all HTTP/HTTPS traffic in your program. If you're using HTTP/2, the http2-wrapper package provides proxy support out-of-box.\\ Learn more.","title":"Proxying"},{"location":"tips/#retry-without-an-agent","text":"If you're using proxies, you may run into connection issues.\\ One way out is to disable proxies when retrying. The solution for the Stream API looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import https from \"https\" ; import fs from \"fs\" ; import got from \"got\" ; class MyAgent extends https . Agent { createConnection ( port , options , callback ) { console . log ( `Connecting with MyAgent` ); return https . Agent . prototype . createConnection . call ( this , port , options , callback ); } } const proxy = new MyAgent (); let writeStream ; const fn = ( retryStream ) => { const options = { agent : { https : proxy , }, }; const stream = retryStream ?? got . stream ( \"https://example.com\" , options ); if ( writeStream ) { writeStream . destroy (); } writeStream = fs . createWriteStream ( \"example-com.html\" ); stream . pipe ( writeStream ); stream . once ( \"retry\" , ( retryCount , error , createRetryStream ) => { fn ( createRetryStream ({ agent : { http : undefined , https : undefined , http2 : undefined , }, }) ); }); }; fn ();","title":"Retry without an agent"},{"location":"tips/#h2c","text":"There is no direct h2c support. However, you can provide a h2session option in a beforeRequest hook. See an example .","title":"h2c"},{"location":"tips/#uppercase-headers","text":"Got always normalizes the headers, therefore passing an Uppercase-Header will transform it into uppercase-header . To fix this, you need to pass a wrapped agent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class WrappedAgent { constructor ( agent ) { this . agent = agent ; } addRequest ( request , options ) { return this . agent . addRequest ( request , options ); } get keepAlive () { return this . agent . keepAlive ; } get maxSockets () { return this . agent . maxSockets ; } get options () { return this . agent . options ; } get defaultPort () { return this . agent . defaultPort ; } get protocol () { return this . agent . protocol ; } } class TransformHeadersAgent extends WrappedAgent { addRequest ( request , options ) { const headers = request . getHeaderNames (); for ( const header of headers ) { request . setHeader ( this . transformHeader ( header ), request . getHeader ( header )); } return super . addRequest ( request , options ); } transformHeader ( header ) { return header . split ( \"-\" ) . map (( part ) => { return part [ 0 ]. toUpperCase () + part . slice ( 1 ); }) . join ( \"-\" ); } } const agent = new http . Agent ({ keepAlive : true , }); const wrappedAgent = new TransformHeadersAgent ( agent ); See an example .","title":"Uppercase headers"},{"location":"tips/#custom-options","text":"Got v12 throws when an option does not exist. Therefore passing a top-level option such as: 1 2 3 4 5 import got from \"got\" ; await got ( \"https://example.com\" , { foo : \"bar\" , }); will throw. To prevent this, you need read the option in an init hook: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import got from \"got\" ; const convertFoo = got . extend ({ hooks : { init : [ ( rawOptions , options ) => { if ( \"foo\" in rawOptions ) { options . context . foo = rawOptions . foo ; delete rawOptions . foo ; } }, ], }, }); const instance = got . extend ( convertFoo , { hooks : { beforeRequest : [ ( options ) => { options . headers . foo = options . context . foo ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { foo : \"bar\" }). json (); console . log ( headers . Foo ); //=> 'bar' Eventually, you may want to create a catch-all instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import got from \"got\" ; const catchAllOptions = got . extend ({ hooks : { init : [ ( raw , options ) => { for ( const key in raw ) { if ( ! ( key in options )) { options . context [ key ] = raw [ key ]; delete raw [ key ]; } } }, ], }, }); const instance = got . extend ( catchAllOptions , { hooks : { beforeRequest : [ ( options ) => { // All custom options will be visible under `options.context` options . headers . foo = options . context . foo ; }, ], }, }); const { headers } = await instance ( \"https://httpbin.org/anything\" , { foo : \"bar\" }). json (); console . log ( headers . Foo ); //=> 'bar' Note: It's a good practice to perform the validation inside the init hook. You can safely throw when an option is unknown! Internally, Got uses the @sindresorhus/is package.","title":"Custom options"},{"location":"tips/#electron-net-module-is-not-supported","text":"Note: Got v12 and later is an ESM package, but Electron does not yet support ESM. So you need to use Got v11. Got doesn't support the electron.net module. It's missing crucial APIs that are available in Node.js.\\ While Got used to support electron.net , it got very unstable and caused many errors. However, you can use IPC communication to get the Response object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Main process const got = require ( \"got\" ); const instance = got . extend ({ // ... }); ipcMain . handle ( \"got\" , async ( event , ... args ) => { const { statusCode , headers , body } = await instance (... args ); return { statusCode , headers , body }; }); // Renderer process async () => { const { statusCode , headers , body } = await ipcRenderer . invoke ( \"got\" , \"https://httpbin.org/anything\" ); // ... };","title":"Electron net module is not supported"},{"location":"typescript/","text":"TypeScript \u00b6 Got \u662f\u5b8c\u5168\u7528 TypeScript \u7f16\u5199\u7684\uff0c\u6240\u4ee5\u96c6\u6210\u662f\u65e0\u7f1d\u7684 \u6b64\u5916\uff0c\u7c7b\u578b\u4f7f Got \u907f\u514d\u4e86\u8bb8\u591a\u9519\u8bef\u548c\u4e0d\u4e00\u81f4\u3002 \u4e0b\u9762\u662f Got \u5bfc\u51fa\u7684\u7c7b\u578b\u5217\u8868: Note \u8fd9\u4e2a\u5217\u8868\u53ef\u80fd\u4e0d\u5b8c\u6574\u3002\u5982\u679c\u4f60\u53d1\u73b0\u4e00\u4e2a\u7c7b\u578b\u662f\u7f3a\u5931\u7684\uff0c\u8bf7\u6253\u5f00\u4e00\u4e2a\u5173\u4e8e\u5b83\u7684\u95ee\u9898\u3002 Got \u00b6 GotStream \u00b6 GotRequestFunction \u00b6 GotPaginate \u00b6 OptionsWithPagination<T = unknown, R = unknown> \u00b6 OptionsOfTextResponseBody \u00b6 OptionsOfJSONResponseBody \u00b6 OptionsOfBufferResponseBody \u00b6 OptionsOfUnknownResponseBody \u00b6 StrictOptions \u00b6 StreamOptions \u00b6 OptionsInit \u00b6 ExtendOptions \u00b6 PlainResponse \u00b6 Response<T = unknown> \u00b6 Request \u00b6 RequestEvents<T> \u00b6 Progress \u00b6 InstanceDefaults \u00b6 GotReturn \u00b6 HandlerFunction \u00b6 CancelableRequest<T extends Response | Response['body'] = Response['body']> \u00b6 Delays \u00b6 CreateConnectionFunction \u00b6 CheckServerIdentityFunction \u00b6 CacheOptions \u00b6 HttpsOptions \u00b6 PaginateData<BodyType, ElementType> \u00b6 PaginationOptions<ElementType, BodyType> \u00b6 SearchParameters \u00b6 ResponseType \u00b6 FilterData<ElementType> \u00b6 RetryObject \u00b6 RetryFunction \u00b6 ParseJsonFunction \u00b6 StringifyJsonFunction \u00b6 Method \u00b6 ToughCookieJar \u00b6 PromiseCookieJar \u00b6 DnsLookupIpVersion \u00b6 RequestFunction \u00b6 Agents \u00b6 Headers \u00b6 Hooks \u00b6 InitHook \u00b6 BeforeRequestHook \u00b6 BeforeRedirectHook \u00b6 BeforeErrorHook \u00b6 BeforeRetryHook \u00b6 AfterResponseHook \u00b6","title":"TypeScript"},{"location":"typescript/#typescript","text":"Got \u662f\u5b8c\u5168\u7528 TypeScript \u7f16\u5199\u7684\uff0c\u6240\u4ee5\u96c6\u6210\u662f\u65e0\u7f1d\u7684 \u6b64\u5916\uff0c\u7c7b\u578b\u4f7f Got \u907f\u514d\u4e86\u8bb8\u591a\u9519\u8bef\u548c\u4e0d\u4e00\u81f4\u3002 \u4e0b\u9762\u662f Got \u5bfc\u51fa\u7684\u7c7b\u578b\u5217\u8868: Note \u8fd9\u4e2a\u5217\u8868\u53ef\u80fd\u4e0d\u5b8c\u6574\u3002\u5982\u679c\u4f60\u53d1\u73b0\u4e00\u4e2a\u7c7b\u578b\u662f\u7f3a\u5931\u7684\uff0c\u8bf7\u6253\u5f00\u4e00\u4e2a\u5173\u4e8e\u5b83\u7684\u95ee\u9898\u3002","title":"TypeScript"},{"location":"typescript/#got","text":"","title":"Got"},{"location":"typescript/#gotstream","text":"","title":"GotStream"},{"location":"typescript/#gotrequestfunction","text":"","title":"GotRequestFunction"},{"location":"typescript/#gotpaginate","text":"","title":"GotPaginate"},{"location":"typescript/#optionswithpaginationt-unknown-r-unknown","text":"","title":"OptionsWithPagination&lt;T = unknown, R = unknown&gt;"},{"location":"typescript/#optionsoftextresponsebody","text":"","title":"OptionsOfTextResponseBody"},{"location":"typescript/#optionsofjsonresponsebody","text":"","title":"OptionsOfJSONResponseBody"},{"location":"typescript/#optionsofbufferresponsebody","text":"","title":"OptionsOfBufferResponseBody"},{"location":"typescript/#optionsofunknownresponsebody","text":"","title":"OptionsOfUnknownResponseBody"},{"location":"typescript/#strictoptions","text":"","title":"StrictOptions"},{"location":"typescript/#streamoptions","text":"","title":"StreamOptions"},{"location":"typescript/#optionsinit","text":"","title":"OptionsInit"},{"location":"typescript/#extendoptions","text":"","title":"ExtendOptions"},{"location":"typescript/#plainresponse","text":"","title":"PlainResponse"},{"location":"typescript/#responset-unknown","text":"","title":"Response&lt;T = unknown&gt;"},{"location":"typescript/#request","text":"","title":"Request"},{"location":"typescript/#requesteventst","text":"","title":"RequestEvents&lt;T&gt;"},{"location":"typescript/#progress","text":"","title":"Progress"},{"location":"typescript/#instancedefaults","text":"","title":"InstanceDefaults"},{"location":"typescript/#gotreturn","text":"","title":"GotReturn"},{"location":"typescript/#handlerfunction","text":"","title":"HandlerFunction"},{"location":"typescript/#cancelablerequestt-extends-response-responsebody-responsebody","text":"","title":"CancelableRequest&lt;T extends Response | Response['body'] = Response['body']&gt;"},{"location":"typescript/#delays","text":"","title":"Delays"},{"location":"typescript/#createconnectionfunction","text":"","title":"CreateConnectionFunction"},{"location":"typescript/#checkserveridentityfunction","text":"","title":"CheckServerIdentityFunction"},{"location":"typescript/#cacheoptions","text":"","title":"CacheOptions"},{"location":"typescript/#httpsoptions","text":"","title":"HttpsOptions"},{"location":"typescript/#paginatedatabodytype-elementtype","text":"","title":"PaginateData&lt;BodyType, ElementType&gt;"},{"location":"typescript/#paginationoptionselementtype-bodytype","text":"","title":"PaginationOptions&lt;ElementType, BodyType&gt;"},{"location":"typescript/#searchparameters","text":"","title":"SearchParameters"},{"location":"typescript/#responsetype","text":"","title":"ResponseType"},{"location":"typescript/#filterdataelementtype","text":"","title":"FilterData&lt;ElementType&gt;"},{"location":"typescript/#retryobject","text":"","title":"RetryObject"},{"location":"typescript/#retryfunction","text":"","title":"RetryFunction"},{"location":"typescript/#parsejsonfunction","text":"","title":"ParseJsonFunction"},{"location":"typescript/#stringifyjsonfunction","text":"","title":"StringifyJsonFunction"},{"location":"typescript/#method","text":"","title":"Method"},{"location":"typescript/#toughcookiejar","text":"","title":"ToughCookieJar"},{"location":"typescript/#promisecookiejar","text":"","title":"PromiseCookieJar"},{"location":"typescript/#dnslookupipversion","text":"","title":"DnsLookupIpVersion"},{"location":"typescript/#requestfunction","text":"","title":"RequestFunction"},{"location":"typescript/#agents","text":"","title":"Agents"},{"location":"typescript/#headers","text":"","title":"Headers"},{"location":"typescript/#hooks","text":"","title":"Hooks"},{"location":"typescript/#inithook","text":"","title":"InitHook"},{"location":"typescript/#beforerequesthook","text":"","title":"BeforeRequestHook"},{"location":"typescript/#beforeredirecthook","text":"","title":"BeforeRedirectHook"},{"location":"typescript/#beforeerrorhook","text":"","title":"BeforeErrorHook"},{"location":"typescript/#beforeretryhook","text":"","title":"BeforeRetryHook"},{"location":"typescript/#afterresponsehook","text":"","title":"AfterResponseHook"},{"location":"examples/","text":"\u4e3e\u4f8b \u00b6","title":"\u4e3e\u4f8b"},{"location":"examples/#_1","text":"","title":"\u4e3e\u4f8b"},{"location":"includes/abbreviations/","text":"","title":"Abbreviations"},{"location":"migration-guides/","text":"Migration guides \u00b6 You may think it's too hard to switch, but it's really not. \ud83e\udd84","title":"Migration guides"},{"location":"migration-guides/#migration-guides","text":"You may think it's too hard to switch, but it's really not. \ud83e\udd84","title":"Migration guides"},{"location":"migration-guides/axios/","text":"Axios \u00b6 Axios is very similar to Got. The difference is that Axios targets browsers first, while Got fully makes use of Node.js features. Common options \u00b6 These options remain the same as well: url method headers maxRedirects decompress Renamed options \u00b6 We deeply care about readability, so we renamed these options: httpAgent \u2192 agent.http httpsAgent \u2192 agent.https socketPath \u2192 url responseEncoding \u2192 encoding auth.username \u2192 username auth.password \u2192 password data \u2192 body / json / form params \u2192 searchParams Changes in behavior \u00b6 transformRequest \u2192 hooks.beforeRequest The API is different. transformResponse \u2192 hooks.afterResponse The API is different. baseUrl \u2192 prefixUrl The prefixUrl is always prepended to the url . timeout This option is now an object. You can now set timeouts on particular events! responseType Accepts 'text' , 'json' or 'buffer' . Breaking changes \u00b6 onUploadProgress This option does not exist. Instead, use got(\u2026).on('uploadProgress', \u2026) . onDownloadProgress This option does not exist. Instead, use got(\u2026).on('downloadProgress', \u2026) . maxContentLength This option does not exist. Instead, use a handler . validateStatus This option does not exist. Got automatically validates the status according to the specification . proxy This option does not exist. You need to pass an agent instead. cancelToken This option does not exist, but will be implemented soon. For now, use promise.cancel() or stream.destroy() . paramsSerializer This option does not exist. maxBodyLength This option does not exist. Response \u00b6 The response object is different as well: response.data \u2192 response.body response.status \u2192 response.statusCode response.statusText \u2192 response.statusMessage response.config \u2192 response.request.options response.request Returns a Got stream . The response.headers object remains the same. Interceptors \u00b6 Got offers hooks instead, which are more flexible. Errors \u00b6 Errors look the same, with the difference error.request returns a Got stream. Furthermore, Got provides more details to make debugging easier. Cancelation \u00b6 While Got doesn't support AbortController yet, you can use promise.cancel() . Convenience methods \u00b6 Convenience methods, such as axios.get(\u2026) etc. remain the same: got.get(\u2026) . Instead of axios.create(\u2026) use got.extend(\u2026) . You're good to go! \u00b6 Well, you have already come this far \\ Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"Axios"},{"location":"migration-guides/axios/#axios","text":"Axios is very similar to Got. The difference is that Axios targets browsers first, while Got fully makes use of Node.js features.","title":"Axios"},{"location":"migration-guides/axios/#common-options","text":"These options remain the same as well: url method headers maxRedirects decompress","title":"Common options"},{"location":"migration-guides/axios/#renamed-options","text":"We deeply care about readability, so we renamed these options: httpAgent \u2192 agent.http httpsAgent \u2192 agent.https socketPath \u2192 url responseEncoding \u2192 encoding auth.username \u2192 username auth.password \u2192 password data \u2192 body / json / form params \u2192 searchParams","title":"Renamed options"},{"location":"migration-guides/axios/#changes-in-behavior","text":"transformRequest \u2192 hooks.beforeRequest The API is different. transformResponse \u2192 hooks.afterResponse The API is different. baseUrl \u2192 prefixUrl The prefixUrl is always prepended to the url . timeout This option is now an object. You can now set timeouts on particular events! responseType Accepts 'text' , 'json' or 'buffer' .","title":"Changes in behavior"},{"location":"migration-guides/axios/#breaking-changes","text":"onUploadProgress This option does not exist. Instead, use got(\u2026).on('uploadProgress', \u2026) . onDownloadProgress This option does not exist. Instead, use got(\u2026).on('downloadProgress', \u2026) . maxContentLength This option does not exist. Instead, use a handler . validateStatus This option does not exist. Got automatically validates the status according to the specification . proxy This option does not exist. You need to pass an agent instead. cancelToken This option does not exist, but will be implemented soon. For now, use promise.cancel() or stream.destroy() . paramsSerializer This option does not exist. maxBodyLength This option does not exist.","title":"Breaking changes"},{"location":"migration-guides/axios/#response","text":"The response object is different as well: response.data \u2192 response.body response.status \u2192 response.statusCode response.statusText \u2192 response.statusMessage response.config \u2192 response.request.options response.request Returns a Got stream . The response.headers object remains the same.","title":"Response"},{"location":"migration-guides/axios/#interceptors","text":"Got offers hooks instead, which are more flexible.","title":"Interceptors"},{"location":"migration-guides/axios/#errors","text":"Errors look the same, with the difference error.request returns a Got stream. Furthermore, Got provides more details to make debugging easier.","title":"Errors"},{"location":"migration-guides/axios/#cancelation","text":"While Got doesn't support AbortController yet, you can use promise.cancel() .","title":"Cancelation"},{"location":"migration-guides/axios/#convenience-methods","text":"Convenience methods, such as axios.get(\u2026) etc. remain the same: got.get(\u2026) . Instead of axios.create(\u2026) use got.extend(\u2026) .","title":"Convenience methods"},{"location":"migration-guides/axios/#youre-good-to-go","text":"Well, you have already come this far \\ Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"You're good to go!"},{"location":"migration-guides/nodejs/","text":"Node.js \u00b6 Let's make a simple request. With Node.js, this is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import http from \"node:http\" ; const request = http . request ( \"https://httpbin.org/anything\" , ( response ) => { if ( response . statusCode >= 400 ) { request . destroy ( new Error ()); return ; } const chunks = []; response . on ( \"data\" , ( chunk ) => { chunks . push ( chunk ); }); response . once ( \"end\" , () => { const buffer = Buffer . concat ( chunks ); if ( response . statusCode >= 400 ) { const error = new Error ( `Unsuccessful response: ${ response . statusCode } ` ); error . body = buffer . toString (); return ; } const text = buffer . toString (); console . log ( text ); }); response . once ( \"error\" , console . error ); }); request . once ( \"error\" , console . error ); request . end (); With Got, this becomes: 1 2 3 4 5 6 7 8 import got from \"got\" ; try { const { body } = await got ( \"https://httpbin.org/anything\" ); console . log ( body ); } catch ( error ) { console . error ( error ); } Much cleaner. But what about streams? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import http from \"node:http\" ; import fs from \"node:fs\" ; const source = fs . createReadStream ( \"article.txt\" ); const request = http . request ( \"https://httpbin.org/anything\" , { method : \"POST\" , }, ( response ) => { response . pipe ( fs . createWriteStream ( \"httpbin.txt\" )); } ); source . pipe ( request ); Well, it's easy as that: 1 2 3 4 5 6 7 8 9 import got from \"got\" ; import stream from \"node:stream\" ; import fs from \"node:fs\" ; await stream . promises . pipeline ( fs . createReadStream ( \"article.txt\" ), got . stream . post ( \"https://httpbin.org/anything\" ), fs . createWriteStream ( \"httpbin.txt\" ) ); The advantage is that Got also handles errors automatically, so you don't have to create custom listeners. Furthermore, Got supports redirects, compression, advanced timeouts, cache, pagination, cookies, hooks, and more! What next? \u00b6 Unfortunately Got options differ too much from the Node.js options. It's not possible to provide a brief summary.\\ Don't worry, you will learn them fast - they are easy to understand! Every option has an example attached. Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"Node.js"},{"location":"migration-guides/nodejs/#nodejs","text":"Let's make a simple request. With Node.js, this is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import http from \"node:http\" ; const request = http . request ( \"https://httpbin.org/anything\" , ( response ) => { if ( response . statusCode >= 400 ) { request . destroy ( new Error ()); return ; } const chunks = []; response . on ( \"data\" , ( chunk ) => { chunks . push ( chunk ); }); response . once ( \"end\" , () => { const buffer = Buffer . concat ( chunks ); if ( response . statusCode >= 400 ) { const error = new Error ( `Unsuccessful response: ${ response . statusCode } ` ); error . body = buffer . toString (); return ; } const text = buffer . toString (); console . log ( text ); }); response . once ( \"error\" , console . error ); }); request . once ( \"error\" , console . error ); request . end (); With Got, this becomes: 1 2 3 4 5 6 7 8 import got from \"got\" ; try { const { body } = await got ( \"https://httpbin.org/anything\" ); console . log ( body ); } catch ( error ) { console . error ( error ); } Much cleaner. But what about streams? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import http from \"node:http\" ; import fs from \"node:fs\" ; const source = fs . createReadStream ( \"article.txt\" ); const request = http . request ( \"https://httpbin.org/anything\" , { method : \"POST\" , }, ( response ) => { response . pipe ( fs . createWriteStream ( \"httpbin.txt\" )); } ); source . pipe ( request ); Well, it's easy as that: 1 2 3 4 5 6 7 8 9 import got from \"got\" ; import stream from \"node:stream\" ; import fs from \"node:fs\" ; await stream . promises . pipeline ( fs . createReadStream ( \"article.txt\" ), got . stream . post ( \"https://httpbin.org/anything\" ), fs . createWriteStream ( \"httpbin.txt\" ) ); The advantage is that Got also handles errors automatically, so you don't have to create custom listeners. Furthermore, Got supports redirects, compression, advanced timeouts, cache, pagination, cookies, hooks, and more!","title":"Node.js"},{"location":"migration-guides/nodejs/#what-next","text":"Unfortunately Got options differ too much from the Node.js options. It's not possible to provide a brief summary.\\ Don't worry, you will learn them fast - they are easy to understand! Every option has an example attached. Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"What next?"},{"location":"migration-guides/request/","text":"Request \u00b6 Let's take the very first example from Request's readme : 1 2 3 4 5 6 7 import request from \"request\" ; request ( \"https://google.com\" , ( error , response , body ) => { console . log ( \"error:\" , error ); console . log ( \"statusCode:\" , response && response . statusCode ); console . log ( \"body:\" , body ); }); With Got, it is: 1 2 3 4 5 6 7 8 9 import got from \"got\" ; try { const response = await got ( \"https://google.com\" ); console . log ( \"statusCode:\" , response . statusCode ); console . log ( \"body:\" , response . body ); } catch ( error ) { console . log ( \"error:\" , error ); } Looks better now, huh? \ud83d\ude0e Common options \u00b6 These Got options are the same as with Request: url body followRedirect encoding maxRedirects localAddress headers createConnection UNIX sockets : http://unix:SOCKET:PATH The time option does not exist, assume it's always true . So if you're familiar with these, you're good to go. Renamed options \u00b6 Note: Got stores HTTPS options inside httpsOptions . Some of them have been renamed. Read more . Readability is very important to us, so we have different names for these options: qs \u2192 searchParams strictSSL \u2192 rejectUnauthorized gzip \u2192 decompress jar \u2192 cookieJar (accepts tough-cookie jar) jsonReviver \u2192 parseJson jsonReplacer \u2192 stringifyJson Changes in behavior \u00b6 The agent option is now an object with http , https and http2 properties. The timeout option is now an object. You can set timeouts on particular events! The searchParams option is always serialized using URLSearchParams . In order to pass a custom query string, provide it with the url option.\\ got('https://example.com', {searchParams: {test: ''}}) \u2192 https://example.com/?test= \\ got('https://example.com/?test') \u2192 https://example.com/?test To use streams, call got.stream(url, options) or got(url, {\u2026, isStream: true}) . Breaking changes \u00b6 The json option is not a boolean , it's an object . It will be stringified and used as a body. The form option is an object and will be used as application/x-www-form-urlencoded body. All headers are converted to lowercase.\\ According to the spec , the headers are case-insensitive. No oauth / hawk / aws / httpSignature option.\\ To sign requests, you need to create a custom instance . No agentClass / agentOptions / pool option. No forever option.\\ You need to pass an agent with keepAlive option set to true . No proxy option. You need to pass a custom agent . No auth option.\\ You need to use username / password instead or set the authorization header manually. No baseUrl option.\\ Instead, there is prefixUrl which appends a trailing slash if not present. No removeRefererHeader option.\\ You can remove the referer header in a beforeRequest hook . No followAllRedirects option. Hooks are very powerful. Read more to see what else you achieve using hooks. More about streams \u00b6 Let's take a quick look at another example from Request's readme: 1 2 3 4 5 http . createServer (( serverRequest , serverResponse ) => { if ( serverRequest . url === \"/doodle.png\" ) { serverRequest . pipe ( request ( \"https://example.com/doodle.png\" )). pipe ( serverResponse ); } }); The cool feature here is that Request can proxy headers with the stream, but Got can do that too! 1 2 3 4 5 6 7 8 9 10 11 12 13 import { promisify } from \"node:util\" ; import stream from \"node:stream\" ; import got from \"got\" ; const pipeline = promisify ( stream . pipeline ); const server = http . createServer ( async ( serverRequest , serverResponse ) => { if ( serverRequest . url === \"/doodle.png\" ) { await pipeline ( got . stream ( \"https://example.com/doodle.png\" ), serverResponse ); } }); server . listen ( 8080 ); In terms of streams nothing has really changed. Convenience methods \u00b6 If you were using request.get , request.post , and so on - you can do the same with Got. The request.defaults({\u2026}) method has been renamed. You can do the same with got.extend({\u2026}) . There is no request.cookie() nor request.jar() . You have to use tough-cookie directly. You're good to go! \u00b6 Well, you have already come this far \\ Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"Request"},{"location":"migration-guides/request/#request","text":"Let's take the very first example from Request's readme : 1 2 3 4 5 6 7 import request from \"request\" ; request ( \"https://google.com\" , ( error , response , body ) => { console . log ( \"error:\" , error ); console . log ( \"statusCode:\" , response && response . statusCode ); console . log ( \"body:\" , body ); }); With Got, it is: 1 2 3 4 5 6 7 8 9 import got from \"got\" ; try { const response = await got ( \"https://google.com\" ); console . log ( \"statusCode:\" , response . statusCode ); console . log ( \"body:\" , response . body ); } catch ( error ) { console . log ( \"error:\" , error ); } Looks better now, huh? \ud83d\ude0e","title":"Request"},{"location":"migration-guides/request/#common-options","text":"These Got options are the same as with Request: url body followRedirect encoding maxRedirects localAddress headers createConnection UNIX sockets : http://unix:SOCKET:PATH The time option does not exist, assume it's always true . So if you're familiar with these, you're good to go.","title":"Common options"},{"location":"migration-guides/request/#renamed-options","text":"Note: Got stores HTTPS options inside httpsOptions . Some of them have been renamed. Read more . Readability is very important to us, so we have different names for these options: qs \u2192 searchParams strictSSL \u2192 rejectUnauthorized gzip \u2192 decompress jar \u2192 cookieJar (accepts tough-cookie jar) jsonReviver \u2192 parseJson jsonReplacer \u2192 stringifyJson","title":"Renamed options"},{"location":"migration-guides/request/#changes-in-behavior","text":"The agent option is now an object with http , https and http2 properties. The timeout option is now an object. You can set timeouts on particular events! The searchParams option is always serialized using URLSearchParams . In order to pass a custom query string, provide it with the url option.\\ got('https://example.com', {searchParams: {test: ''}}) \u2192 https://example.com/?test= \\ got('https://example.com/?test') \u2192 https://example.com/?test To use streams, call got.stream(url, options) or got(url, {\u2026, isStream: true}) .","title":"Changes in behavior"},{"location":"migration-guides/request/#breaking-changes","text":"The json option is not a boolean , it's an object . It will be stringified and used as a body. The form option is an object and will be used as application/x-www-form-urlencoded body. All headers are converted to lowercase.\\ According to the spec , the headers are case-insensitive. No oauth / hawk / aws / httpSignature option.\\ To sign requests, you need to create a custom instance . No agentClass / agentOptions / pool option. No forever option.\\ You need to pass an agent with keepAlive option set to true . No proxy option. You need to pass a custom agent . No auth option.\\ You need to use username / password instead or set the authorization header manually. No baseUrl option.\\ Instead, there is prefixUrl which appends a trailing slash if not present. No removeRefererHeader option.\\ You can remove the referer header in a beforeRequest hook . No followAllRedirects option. Hooks are very powerful. Read more to see what else you achieve using hooks.","title":"Breaking changes"},{"location":"migration-guides/request/#more-about-streams","text":"Let's take a quick look at another example from Request's readme: 1 2 3 4 5 http . createServer (( serverRequest , serverResponse ) => { if ( serverRequest . url === \"/doodle.png\" ) { serverRequest . pipe ( request ( \"https://example.com/doodle.png\" )). pipe ( serverResponse ); } }); The cool feature here is that Request can proxy headers with the stream, but Got can do that too! 1 2 3 4 5 6 7 8 9 10 11 12 13 import { promisify } from \"node:util\" ; import stream from \"node:stream\" ; import got from \"got\" ; const pipeline = promisify ( stream . pipeline ); const server = http . createServer ( async ( serverRequest , serverResponse ) => { if ( serverRequest . url === \"/doodle.png\" ) { await pipeline ( got . stream ( \"https://example.com/doodle.png\" ), serverResponse ); } }); server . listen ( 8080 ); In terms of streams nothing has really changed.","title":"More about streams"},{"location":"migration-guides/request/#convenience-methods","text":"If you were using request.get , request.post , and so on - you can do the same with Got. The request.defaults({\u2026}) method has been renamed. You can do the same with got.extend({\u2026}) . There is no request.cookie() nor request.jar() . You have to use tough-cookie directly.","title":"Convenience methods"},{"location":"migration-guides/request/#youre-good-to-go","text":"Well, you have already come this far \\ Take a look at the documentation . It's worth the time to read it.\\ There are some great tips . If something is unclear or doesn't work as it should, don't hesitate to open an issue .","title":"You're good to go!"},{"location":"tags/","text":"\u6807\u7b7e \u00b6","title":"\u6807\u7b7e"},{"location":"tags/#_1","text":"","title":"\u6807\u7b7e"}]}